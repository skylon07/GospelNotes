			<!DOCTYPE html>
				<html>
				<head>
					<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
				</head>
				<body>
					<script src="react.production.min.js"></script>
<script src="react-dom.production.min.js"></script>
<script src="Libraries/lunr.min.js"></script>
					
					<div id="root"><h2 style="background-color: rgb(254, 1, 2); color: white;">(Javascript did not load)</h2></div>
					<script>
						"use strict"
						try {
							
							const root = document.getElementById("root")
							root.innerHTML = "" // resets error message
							eval(`const VERSION = {
	number: "0.2.1",
	credits: \`\\
	Creator: Taylor Brown
	\\n
	---- Special Thanks! ;) ----
	*Ashlyn Brown*
	Quality Assurance and bug testing
	\\n
	*Facebook Devs*
	An awesome JS Library (React)
	\\n
	*All Babel.js Devs*
	Another awesome JS Library
	\\n
	*GitHub: olivernn*
	A "not-as-bright" indexing engine
	(and yet very useful!)\`

	// allows wrapping in case of loading errors
};const main = function () {

	/* MODULE INFO:
 	Gives easy access for working with Babel and activating plugins.
 */

	class BabelWorker {
		static getPlugin(name) {
			return Babel.availablePlugins[name];
		}
		static listPlugins() {
			return Babel.availablePlugins;
		}

		constructor(plugins) {
			if (!(plugins instanceof Array)) {
				throw new Error(\`BabelWorker must be given an array of plugins (of strings or plugin modules)\`);
			}
			this._plugins = plugins.map(plugin => {
				if (typeof plugin === "string") {
					let pluginStr = plugin;
					plugin = BabelWorker.getPlugin(plugin);
					if (!plugin) {
						throw new Error(\`BabelWorker plugin '\${pluginStr}' does not exist\`);
					}
				}
				return plugin;
			});
		}

		transform(code) {
			return Babel.transform(code, { plugins: this._plugins }).code;
		}

		// splits a string into smaller fragments recursively given a maximum length
		// NOTE: this function is unfinished/partially working
		_splitCodeFragments(str, maxLength = 2000, start = null, end = null) {
			let calcLength = str.length;
			let blocks = [];
			let lastBlockEnd = 0;
			while (calcLength > maxLength) {
				const blockStart = this._getBlockStart(str, lastBlockEnd);
				if (blockStart === -1) {
					// do something different?
					break;
				}
				const blockEnd = this._getBlockPair(str, blockStart);
				if (blockEnd === -1) {
					throw new Error(\`BabelWorker found an unterminated block pair; ensure code is formatted correctly\`);
				}
				const blockSize = blockEnd - blockStart;

				// dont transform something pathetic, like an "if" statement
				if (blockSize > 500) {
					calcLength -= blockSize;
					blocks.push({ start: blockStart, end: blockEnd });
				}
				lastBlockEnd = blockEnd;
			}

			let insertAdj = 0;
			for (let i = 0; i < blocks.length; i++) {
				const blockData = blocks[i];
				blockData.str = str.slice(blockData.start, blockData.end);

				str = str.slice(0, blockData.start + insertAdj) + str.slice(blockData.end + insertAdj);
				insertAdj -= blockData.str.length;
			}

			return { str: str, blocks, start, end };
		}

		// gets the index immediately after the next ') {' (skipping strings and such)
		_getBlockStart(str, idx = 0) {
			while (idx < str.length) {
				idx = this._skipLiterals(str, idx);
				const isBlockStart = this._isBlockStart(str, idx);
				if (isBlockStart) {
					return isBlockStart;
				} else {
					idx++;
				}
			}
			return -1;
		}
		_isBlockStart(str, idx, char = str[idx]) {
			if (char === ')') {
				let nextNotSpaceIdx = idx + 1;
				let nextNotSpace = str[nextNotSpaceIdx];
				while (nextNotSpace === ' ' || nextNotSpace === '\\n' || nextNotSpace === '\\t') {
					nextNotSpace = str[++nextNotSpaceIdx];
				}
				if (nextNotSpace === '{') {
					// conditions met!
					return nextNotSpaceIdx + 1;
				}
			}
			return null;
		}

		// starting at an index of a block start, this returns its pair ending brace
		_getBlockPair(str, idx = 0) {
			let openBlockCount = 0;
			while (idx < str.length) {
				idx = this._skipLiterals(str, idx);
				const char = str[idx];

				// this way it also "skips" objects (originally used _isBlockStart, except that doesnt skip objects...)
				if (char === '{') {
					openBlockCount++;
				} else if (char === '}') {
					if (openBlockCount === 0) {
						// conditions met!
						return idx;
					}
					openBlockCount--;
				}
				idx++;
			}
			return -1;
		}

		// like one iteration of indexOf(), but it skips things like strings and comments
		_skipLiterals(str, idx) {
			const char = str[idx];

			// skip strings
			if (char === '"' || char === "'" || char === '\`') {
				let pairIdx = str.indexOf(char, idx + 1);
				while (str[pairIdx - 1] === '\\\\') {
					pairIdx = str.indexOf(char, pairIdx + 1);
					if (pairIdx === -1) {
						throw new Error(\`BabelWorker found an unterminated string constant\`);
					}
				}
				return pairIdx + 1;
			}

			// skip inline comments and block comments
			else if (char === '/') {
					const next = str[idx + 1];
					if (next === '*') {
						let pairIdx = str.indexOf('*/', idx + 1);
						if (pairIdx === -1) {
							throw new Error(\`BabelWorker found an unterminated block comment\`);
						}
						return pairIdx + 2;
					} else if (next === '/') {
						let newlineIdx = str.indexOf('\\n', idx + 1);
						if (newlineIdx === -1) {
							return str.length;
						}
						return;
					}
				}

			// didnt skip anything
			return idx;
		}
	}

	/* MODULE INFO:
 	Allows easy access to interacting with the users clipboard. It also
 	can hold its own history, and provides some functions which act on
 	DOM events.
 */

	class ClipboardOperator {
		constructor(maxClips = 1, initClips = []) {
			this._maxClips = maxClips;
			this._clips = initClips;
			this._keepLimit();

			this._bindRecordToEvent();
		}

		copy(text, toClipboard = false) {
			this._clips.unshift(text);
			this._keepLimit();

			if (toClipboard) {
				ClipboardOperator.copyToClipboard(text);
			}

			return text;
		}
		onCopy(event) {}
		// overridden by implementation


		// NOTE: pasting to clipboard only works inside user generated events (due to security restrictions)
		paste(force = "") {
			if (force !== "force" && !this._pasteAvailable) {
				throw new Error(\`Cannot request paste() outside onPasteAvailable (override with paste("force") to get last recorded paste)\`);
			}
			return this._lastPaste;
		}
		onPasteAvailable(event) {
			// overidden by implementation
		}

		getClip(idx = 0) {
			return this._clips[idx];
		}

		_keepLimit() {
			if (this._clips.length > this._maxClips) {
				this._clips.length = this._maxClips;
			}
		}

		static copyToClipboard(text) {
			const lastFocus = document.activeElement;

			let textarea = document.createElement("textarea");
			textarea.value = text;

			// NOTE: cant do {textarea.style.display = "none"} because .select() wont work
			document.body.appendChild(textarea);
			textarea.select();
			document.execCommand("copy");
			document.body.removeChild(textarea);

			lastFocus.focus();
		}

		_bindRecordToEvent() {
			document.addEventListener("copy", event => this.onCopy(event));
			this._pasteAvailable = false;
			this._lastPaste = null;
			document.addEventListener("paste", event => this._recordPaste(event));
		}

		_recordPaste(event) {
			this._pasteAvailable = true;
			this._lastPaste = event.clipboardData.getData('text');
			this.onPasteAvailable(event);
			this._pasteAvailable = false;
		}
	}

	/* MODULE INFO:
 	Provides an asynchronous framework for common actions taken on files.
 	It also provides a chunking function which can (asyncronously)
 	perform tasks over longer periods of time.
 */

	class FileTools {
		static async readAsText(blob) {
			const reader = new FileReader();
			reader.readAsText(blob);
			return new Promise((res, rej) => {
				reader.onload = () => res(reader.result);
				reader.onerror = rej;
			});
		}

		// how many characters can be processed in a string per millisecond (for chunk func below)
		// NOTE: actually/optimally around 8-9K; this gives some slack
		static get charsPerMS() {
			return 7500;
		}

		static async chunkOverTime(isDoneFunc, perChunkFunc, allowedMS = 10) {
			let start = new Date();
			for (let i = 0; isDoneFunc(i, allowedMS); i++) {
				perChunkFunc(i, allowedMS);
				if (new Date() - start > allowedMS) {
					await new Promise(res => setTimeout(res));
					start = new Date();
				}
			}
		}

		static downloadTextAs(text, filename) {
			const link = document.createElement('a');
			link.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(text);
			link.download = filename;

			FileTools._click(link);
		}

		// NOTE: file inputs .click() method can only be triggered inside user generated events
		static async uploadFile() {
			return new Promise((res, rej) => {
				const input = document.createElement("input");
				input.type = "file";

				FileTools._click(input);
				input.onchange = () => res(input.files[0]);
				input.onerror = rej;
			});
		}

		static _click(elem) {
			elem.style.display = "none";
			document.body.appendChild(elem);
			elem.click();
			document.body.removeChild(elem);
		}
	}

	/* MODULE INFO:
 	A custom-built file managing system, originally designed for the
 	Code Writer app. It can do everything from adding files and folders,
 	to moving them, listing existing structures, and even selecting a
 	default path to act as "./".
 */

	class FileTree {
		constructor(pathSep = '/', fromRaw = "") {
			if (typeof fromRaw !== "string") {
				throw new Error(\`FileTree only allows strings for the second argument\`);
			}

			this._pathSep = pathSep;
			this._root = new FileTree._Folder('');
			this._selectedFolder = this._root;

			if (fromRaw) {
				this._loadFromStr(fromRaw);
			}
		}

		toString() {
			return "[object FileTree]";
		}

		addFolder(path, select = false) {
			if (path.includes(']')) {
				throw new Error(\`FileTree.addFolder cannot have ']' in name\`);
			}
			const pathList = this._checkPath(path);
			const newFolder = this._travelPathList(pathList, true);
			if (select) {
				this._selectedFolder = newFolder;
			}
		}

		selectFolder(path) {
			const pathList = this._checkPath(path);
			this._selectedFolder = this._travelPathList(pathList);
		}

		getAbsPath(path) {
			const pathList = this._checkPath(path);
			const name = pathList.pop();

			let currFolder = this._travelPathList(pathList);
			const folderPath = this._absPath(currFolder);

			// handles both folder and file destinations
			try {
				const finalFolder = this._travelPathList([name], false, currFolder);
				let finalPath = folderPath;
				if (finalFolder !== currFolder) {
					finalPath += finalFolder.name + this._pathSep;
				}
				return finalPath;
			} catch (folderDoesntExist) {
				return folderPath + name;
			}
		}

		moveFolder(pathFrom, pathTo) {
			const pathFromList = this._checkPath(pathFrom);
			const pathToList = this._checkPath(pathTo);

			const folderToMove = this._travelPathList(pathFromList);
			if (folderToMove === this._root) {
				throw new Error(\`FileTree.moveFolder cannot move root folder\`);
			}

			const folderToMoveTo = this._travelPathList(pathToList, false);
			if (this._checkMovingIntoSelf(folderToMove, folderToMoveTo)) {
				throw new Error(\`FileTree.moveFolder cannot move \${folderToMove.name} to child \${folderToMoveTo.name}\`);
			}
			folderToMoveTo.addChild(folderToMove);
		}

		removeFolder(path, reselect = false) {
			const pathList = this._checkPath(path);
			const targetFolder = this._travelPathList(pathList);
			if (targetFolder === this._root) {
				throw new Error(\`FileTree.removeFolder cannot remove root folder\`);
			}

			if (this._checkRemovingSelected(targetFolder)) {
				throw new Error(\`FileTree.removeFolder cannot remove '\${targetFolder.name}' when selected folder '\${this._selectedFolder.name}' is in the removal tree (use "true" as second argument to auto-reselect to the parent)\`);
			}
			targetFolder.parent.removeChild(targetFolder);
		}

		addFile(path, file) {
			const pathList = this._checkPath(path);
			if (!(file instanceof File)) {
				throw new Error(\`FileTree.addFile cannot add non-File '\${file}'\`);
			} else if (file.name.includes('*')) {
				// due to this character being used in conversion to string
				throw new Error(\`FileTree.addFile cannot add file with '*' in name '\${file.name}'\`);
			} else if (file.name.includes(this._pathSep)) {
				throw new Error(\`FileTree.addFile cannot add file with '\${this._pathSep}' (the path separator) in name '\${file.name}'\`);
			}

			const targetFolder = this._travelPathList(pathList, true);
			targetFolder.addFile(file);
		}

		getFile(path) {
			const pathList = this._checkPath(path);
			const fileName = pathList.pop();

			const targetFolder = this._travelPathList(pathList);
			const file = targetFolder.getFile(fileName);
			if (!file) {
				throw new Error(\`FileTree.getFile cannot get nonexistant file '\${fileName}' from '\${path}'\`);
			}
			return file;
		}

		moveFile(pathFrom, pathTo) {
			const pathFromList = this._checkPath(pathFrom);
			const fileName = pathFromList.pop();
			const pathToList = this._checkPath(pathTo);

			const fileParent = this._travelPathList(pathFromList);
			const file = fileParent.getFile(fileName);
			if (!file) {
				throw new Error(\`FileTree.moveFile cannot move nonexistant file '\${fileName}' from '\${pathFrom}'\`);
			}

			const newParent = this._travelPathList(pathToList);
			fileParent.removeFile(file);
			newParent.addFile(file);
		}

		removeFile(path) {
			const pathList = this._checkPath(path);
			const fileName = pathList.pop();

			const fileParent = this._travelPathList(pathList);
			const file = fileParent.getFile(fileName);
			if (!file) {
				throw new Error(\`FileTree.removeFile cannot remove nonexistant file '\${fileName}' from '\${path}'\`);
			}
			fileParent.removeFile(file);
		}

		list(path = './', only = "all") {
			const pathList = this._checkPath(path);
			const targetFolder = this._travelPathList(pathList);
			switch (only) {
				case 'all':
					{
						return {
							folders: targetFolder.listChildren(),
							files: targetFolder.listFiles()
						};
					}
					break;

				case 'folders':
					{
						return targetFolder.listChildren();
					}
					break;

				case 'files':
					{
						return targetFolder.listFiles();
					}
					break;

				default:
					{
						throw new Error(\`FileTree.list must receive valid second argument ("all", "folders", "files")\`);
					}
					break;
			}
		}

		appendTreeStr(path, treeStr) {
			const pathList = this._checkPath(path);
			const name = pathList.pop();
			const targetFolder = this._travelPathList(pathList, true);

			const fileTree = new FileTree(this._pathSep, treeStr);
			const root = fileTree._root;
			root._name = name;
			targetFolder.addChild(root);
		}

		async convertToStr(path = '/', callback = null) {
			const pathList = this._checkPath(path);
			const targetFolder = this._travelPathList(pathList);

			if (callback) {
				// callback mode
				const result = await this._convertToStr(targetFolder);
				callback(result);
				return result;
			}
			// async function mode
			return this._convertToStr(targetFolder);
		}

		async _convertToStr(root) {
			const [treeStr, fileContentsStr] = await root.convertToStr('');
			// initial file contents is ''
			return treeStr + fileContentsStr;
		}

		_loadFromStr(str) {
			new FileTree._Loader(this).load(str);
		}

		static _escapeNextFile(str, level = 0) {
			let tagStart = '\\n#';
			let tagEnd = 'NEXTFILE#\\n';

			let fromTag = tagStart + ':'.repeat(level) + tagEnd;
			let toTag = tagStart + ':'.repeat(level + 1) + tagEnd;
			if (str.includes(toTag)) {
				str = FileTree._escapeNextFile(str, level + 1);
			}

			return str.replaceAll(fromTag, toTag);
		}

		static _unescapeNextFile(str, level = 0) {
			let tagStart = '\\n#';
			let tagEnd = 'NEXTFILE#\\n';

			let fromTag = tagStart + ':'.repeat(level + 1) + tagEnd;
			let toTag = tagStart + ':'.repeat(level) + tagEnd;
			if (str.includes(fromTag)) {
				str = str.replaceAll(fromTag, toTag);
				return FileTree._unescapeNextFile(str, level + 1);
			} else {
				return str.replaceAll(fromTag, toTag);
			}
		}

		_travelPathList(pathList, create = false, startFolder = this._selectedFolder) {
			let currFolder = startFolder;
			let pathPtr = 0;
			if (pathList[0] === '') {
				currFolder = this._root;
				pathPtr++;
			}

			while (pathPtr < pathList.length) {
				const folderName = pathList[pathPtr++];
				if (!folderName) {
					const origPath = pathList.join(this._pathSep);
					throw new Error(\`FileTree cannot access nameless folder in '\${origPath}'\`);
				} else if (folderName === '..') {
					if (currFolder !== this._root) {
						currFolder = currFolder.parent;
					}
				} else if (folderName === '.') {
					// do nothing, i guess?
				} else {
					currFolder = currFolder.subFolder(folderName, create);
					if (!currFolder) {
						const origPath = pathList.join(this._pathSep);
						throw new Error(\`FileTree cannot access nonexistant folder '\${folderName}' in '\${origPath}'\`);
					}
				}
			}

			return currFolder;
		}

		_checkPath(path) {
			if (typeof path !== 'string' || path === '') {
				throw new Error(\`FileTree functions require "path" to be a non-null string\`);
			}
			return this._parsePath(path);
		}
		_parsePath(validPath) {
			let pathList = validPath.split(this._pathSep);
			if (pathList[pathList.length - 1] === '') {
				// path ends with '/'
				pathList.pop();
			}
			return pathList;
		}

		// NOTE: "checkFolder" is used to signal checking for a parent-child relationship; should never be this._root
		_absPath(startFolder, checkFolder = null) {
			let absPath = '';
			let currFolder = startFolder;
			while (currFolder !== this._root) {
				// all currFolders except this._root should be checked
				if (currFolder === checkFolder) {
					return null;
				}
				absPath = currFolder.name + this._pathSep + absPath;
				currFolder = currFolder.parent;
			}
			return this._pathSep + absPath;
		}

		_checkMovingIntoSelf(moveFrom, moveTo) {
			// moving into self when moveTo is a child of moveFrom
			return this._absPath(moveTo, moveFrom) === null;
		}

		_checkRemovingSelected(targetFolder) {
			// removing selected when selectedFolder is a child of targetFolder
			return this._absPath(this._selectedFolder, targetFolder) === null;
		}

		// class FileTree._Folder
		static get _Folder() {
			if (!FileTree.__Folder) {
				FileTree.__Folder = class {
					constructor(name) {
						this._name = name;
						this._parent = null;

						// objects chosen because accesses take ~1/2 less time than arrays
						// (arrays take ~1/2 less time for iterating over all values)
						this._children = {};
						this._files = {};
					}

					toString() {
						return \`[object FileTree._Folder('\${this._name}')]\`;
					}

					get name() {
						return this._name;
					}

					get parent() {
						return this._parent;
					}

					// NOTE: no error checking enhances performance; FileTree should validate arguments when needed
					addChild(folder) {
						if (folder._parent) {
							delete folder._parent._children[folder._name];
						}

						this._children[folder._name] = folder;
						folder._parent = this;
					}

					removeChild(folder) {
						delete this._children[folder._name];
						folder._parent = null;
					}

					subFolder(name, create = false) {
						let folder = this._children[name];
						if (!folder && create) {
							folder = new FileTree._Folder(name);
							this.addChild(folder);
						}
						return folder;
					}

					listChildren() {
						let names = [];
						for (let childName in this._children) {
							names.push(childName);
						}
						return names.sort();
					}

					addFile(file) {
						this._files[file.name] = file;
					}

					removeFile(file) {
						delete this._files[file.name];
					}

					getFile(name) {
						return this._files[name];
					}

					listFiles() {
						let names = [];
						for (let fileName in this._files) {
							names.push(fileName);
						}
						return names.sort();
					}

					async convertToStr(fileContStr) {
						let result = '';
						for (let childName in this._children) {
							const child = this._children[childName];
							const [childStr, newFileStr] = await child.convertToStr(fileContStr);

							fileContStr = newFileStr;
							result += \`[\${childName}]\\n\${childStr}[..]\\n\`;
						}
						for (let fileName in this._files) {
							const contents = FileTree._escapeNextFile((await this.readFileContents(fileName)));

							result += \`*\${fileName}*\\n\`;
							fileContStr += "\\n#NEXTFILE#\\n" + contents;
						}
						return [result, fileContStr];
					}

					async readFileContents(fileName) {
						return new Promise((res, rej) => {
							const reader = new FileReader();
							reader.onload = () => res(reader.result);
							reader.onerror = rej;

							reader.readAsText(this._files[fileName]);
						});
					}
				};
			}
			return FileTree.__Folder;
		}

		// class FileTree._Loader
		static get _Loader() {
			if (!FileTree.__Loader) {
				FileTree.__Loader = class {
					constructor(parentTree) {
						this.parent = parentTree;

						this.filePathStack = [];

						this.fileContentStart = null;
						this.nextFileTag = "\\n#NEXTFILE#\\n";
					}

					load(str) {
						this.fileContentStart = str.indexOf(this.nextFileTag);
						if (this.fileContentStart === -1) {
							this.fileContentStart = str.length;
						}

						this._loadHierarchy(str);
						this._loadFileContents(str);
					}

					_loadHierarchy(str) {
						let ptr = 0;
						let fullFolderPaths = this.parent._pathSep;
						let currPathList = [];
						while (ptr < this.fileContentStart) {
							const folder = this._isFolderTag(str, ptr);
							const file = this._isFileTag(str, ptr);

							if (folder) {
								fullFolderPaths += folder + this.parent._pathSep;
								if (folder === '..') {
									currPathList.pop();
								} else {
									currPathList.push(folder);
								}
								ptr += folder.length + 3; // '[]\\n'.length
							} else if (file) {
								const currPath = this.parent._pathSep + currPathList.join(this.parent._pathSep);
								this.filePathStack.push([currPath, file]);
								ptr += file.length + 3; // '**\\n'.length
							} else {
								throw new Error(\`FileTree received invalid loading string\`);
							}
						}

						this._createFolders(fullFolderPaths);
					}

					_createFolders(fullPath) {
						const fullPathList = this.parent._parsePath(fullPath);
						this.parent._travelPathList(fullPathList, true);
					}

					_loadFileContents(str) {
						let ptr = this.fileContentStart;
						let count = 0;
						while (ptr < str.length) {
							ptr += this.nextFileTag.length;
							let next = str.indexOf(this.nextFileTag, ptr);
							if (next === -1) {
								next = str.length;
							}
							const content = FileTree._unescapeNextFile(str.slice(ptr, next));
							ptr = next;

							const [filePath, fileName] = this.filePathStack[count++];

							const file = new File([content], fileName);
							this.parent.addFile(filePath, file);
						}
					}

					_isFolderTag(str, ptr) {
						if (str[ptr] === '[') {
							const end = str.indexOf(']', ptr + 1);
							if (str[end + 1] === '\\n') {
								return str.slice(ptr + 1, end);
							}
						}
						return '';
					}
					_isFileTag(str, ptr) {
						if (str[ptr] === '*') {
							const end = str.indexOf('*', ptr + 1);
							if (str[end + 1] === '\\n') {
								return str.slice(ptr + 1, end);
							}
						}
						return '';
					}
				};
			}
			return FileTree.__Loader;
		}
	}

	/* MODULE INFO:
 	A React styling library that helps generate CSS
 	for components on the fly! It also implements a theming/preset tool
 	to help with managing app themes.
 	
 	
 	MAKESTYLE SYNTAX:
 	ReactStyles components utilize a "makeStyle()" function that is
 	called on the first render of the component. This function returns a
 	single object representing the style layout of a component. An
 	example might look like this:
 	
 	makeStyle(when) { // (more on the "when" callback in a bit)
 		// this object turns into a set of CSS rules, which are unique
 		// and (ideally) used for this component only. Each nested object
 		// is processed in the same way as the initally returned one.
 		return {
 			// string values are turned into CSS properties
 			color: "white",
 			
 			// CSS names do not have a '-';
 			// instead, use capitals where '-'s would go
 			backgroundColor: "blue",
 			// if this REALLY bothers you, this is also valid
 			"background-color": "blue",
 			
 			// function values turn into dynamic properties
 			// NOTE: these are called/updated after every render() call
 			color: () => {
 				// ...do stuff to/with "this"
 			}, // dont forget commas!
 			
 			// object values turn into child classes (aka when starting with uppercase)
 			// (ex ".Component .ChildComponent")
 			ChildComponent: {
 				// ...
 			},
 			
 			// this also works for regular DOM elements (aka when starting with lowercase)
 			// (ex ".Component button")
 			button: {
 				// ...
 			},
 			
 			// ...and you can express direct children too
 			// (ex ".Component > button")
 			">button": {
 				// ...
 			},
 			
 			// "when()" can be used to apply subclasses
 			// (ex ".Component.Square")
 			[when("Square")]: { // "[...]" is necessary; this is a JS syntax for representing an object property as an expression
 				// ...
 			},
 			
 			// "when()" is also used to apply pseudo classes
 			// (ex ".Component:active")
 			[when(":active")]: {
 				// ...
 			},
 			
 			// defining animations looks like this
 			// (ex "@keyframes ComponentName-AnimationNameHere")
 			"@keyframes ComponentName-AnimationNameHere": {
 				from: {
 					// ...
 				},
 				
 				// numbers automatically convert to percentages
 				50: {
 					// ...
 				}
 				
 				// (this is also valid)
 				"60%": {
 					// ...
 				}
 			},
 			// NOTE: since animation names are set globally, it is
 			// recommended the animation name starts with the component
 			// name to avoid overwriting other rules
 			
 			// in the rare case you need to define a raw CSS rule (for
 			// example, wrapping a component in a parent container),
 			// applying rules to these can be done like so
 			// (ex ".Component-Container", NOT ".Component .Component-Container")
 			"=.Component-Container": {
 				// ...
 			},
 		}
 	}
 	
 	One thing to consider is how to get static styles and dynamic styles
 	to cooperate. There are several cases where styles should only apply
 	to a single element (for example, after a squash animation, the
 	elements size should be zero). Use Reacts built in "style" property,
 	NOT dynamic styles. Dynamic makeStyle() properties are run every
 	time a component updates, but the results are applied to ALL the
 	components, as if it is a CSS variable.
 */

	class ReactStyles {
		/* PRODUCTION MODE */
		// disables certain features and enables performance optimizations
		static enableProduction() {
			this._checkPropDisabled = true;
			this._themeClassCheckDisabled = true;
		}

		/* COMPONENT STRUCTURE */
		// static class ReactStyles.Component
		static get Component() {
			if (!this._Component) {
				this._Component = this._MyComponentFrom(React.Component);
			}
			return this._Component;
		}

		// static class ReactStyles.PureComponent
		static get PureComponent() {
			if (!this._PureComponent) {
				this._PureComponent = this._MyComponentFrom(React.PureComponent);
			}
			return this._PureComponent;
		}

		// ReactStyles._MyComponentFrom(ReactClass) => class MyComponentMixin
		static _MyComponentFrom(ReactClass) {
			return class extends ReactClass {
				constructor(props) {
					super(props);
					this.__ReactStyles_propsToCheck = [["hidden", "possible-typeof", "boolean"]];
					this.__ReactStyles_dynamicStyles = [];
					this.enableHiddenProp();

					this.__ReactStyles_componentName = this.constructor.name || ReactStyles._getUnnamedComponentName(this.constructor);

					// binding component constructor (static) functions
					if (!this.constructor.__ReactStyles_boundStaticWrapperFuncs) {
						this.constructor.__ReactStyles_bindGetDerivedStateFromProps();
						this.constructor.__ReactStyles_boundStaticWrapperFuncs = true;
					}
					this.__ReactStyles_bindWrapperFuncs();
				}

				get componentName() {
					return this.__ReactStyles_componentName;
				}

				/* PROP CHECKER */
				// in getter form so "const check = this.addCheckForProp" works
				get addCheckForProp() {
					return (prop, checkType, shouldBe) => {
						if (typeof prop !== "string") {
							throw new Error(\`addCheckForProp() first argument must be a string\`);
						}
						if (typeof checkType !== "string") {
							throw new Error(\`addCheckForProp() second argument must be a string\`);
						}

						this.__ReactStyles_propsToCheck.push([prop, checkType, shouldBe]);
					};
				}

				disableHiddenProp(permanent = false) {
					this.__ReactStyles_shouldHandleHiddenProp = false;
					if (permanent) {
						this.__ReactStyles_cannotEnableHiddenProp = true;
					}
				}
				enableHiddenProp() {
					if (!this.__ReactStyles_cannotEnableHiddenProp) {
						this.__ReactStyles_shouldHandleHiddenProp = true;
					}
				}

				__ReactStyles_checkProp(prop, checkType, shouldBe) {
					const className = this.componentName;
					const propVal = this.props[prop];

					// check and handle "possible-" keyword
					const possibleIdx = checkType.indexOf("possible-");
					if (possibleIdx >= 0) {
						if (propVal === null || propVal === undefined) {
							return;
						}
						checkType = checkType.slice(0, possibleIdx) + checkType.slice(possibleIdx + "possible-".length);
					}

					const shouldBeName = shouldBe.constructor && !["Function", "String"].includes(shouldBe.constructor.name) ? shouldBe.constructor.name : shouldBe.name ? shouldBe.name : shouldBe;

					const errorStart = \`(for component \${className}) props.\${prop}\`;
					const gotStr = \`got \${prop}='\${propVal}' (type: \${typeof propVal})\`;

					switch (checkType) {
						case 'typeof':
							{
								if (shouldBe === "object" && !propVal) {
									throw new Error(\`\${errorStart} must be a truthy object; \${gotStr}\`);
								}
								if (typeof shouldBe !== "string") {
									throw new Error(\`#{errorStart} cannot compare typeof to \${shouldBeName}\`);
								}
								if (typeof propVal !== shouldBe) {
									throw new Error(\`\${errorStart} must be of type '\${shouldBeName}'; \${gotStr}\`);
								}
							}
							break;

						case 'instanceof':
							{
								if (!(propVal instanceof shouldBe)) {
									throw new Error(\`\${errorStart} must be an instance of '\${shouldBeName}'; \${gotStr}\`);
								}
							}
							break;

						case 'lengthof':
							{
								if (typeof shouldBe !== 'number') {
									throw new Error(\`\${errorStart} cannot compare size with non-number '\${shouldBeName}'\`);
								}
								if (!propVal || typeof propVal.length !== "number") {
									throw new Error(\`\${errorStart} must have numerical .length property to determine size; \${gotStr}\`);
								}
								if (propVal.length !== shouldBe) {
									throw new Error(\`\${errorStart} is an invalid size (expected \${shouldBeName}, got \${propVal.length})\`);
								}
							}
							break;

						case 'elementof':
							{
								if (typeof shouldBe !== "string") {
									throw new Error(\`\${errorStart} must be given a string; \${gotStr}\`);
								}
								if (!propVal || typeof propVal.type !== "string") {
									throw new Error(\`\${errorStart} is not a valid element representation; \${gotStr}\`);
								}
								if (propVal.type !== shouldBe) {
									throw new Error(\`\${errorStart} is not an element of type \${shouldBeName}; got \${prop}=<\${propVal.type} ... />\`);
								}
							}

						case 'componentof':
							{
								if (typeof shouldBe === "string") {
									throw new Error(\`\${errorStart} must be compared with literal function, not "\${shouldBeName}" (type string)\`);
								}
								if (!propVal && typeof propVal.type !== "function" && typeof propVal.type !== "symbol") {
									throw new Error(\`\${errorStart} is not a valid component representation; \${gotStr}\`);
								}
								if (propVal.type !== shouldBe) {
									throw new Error(\`\${errorStart} is not a component of type \${shouldBeName}; got \${prop}=<\${propVal.type.name} ... />\`);
								}
							}
							break;

						case 'custom':
							{
								if (typeof shouldBe !== "function") {
									throw new Error(\`\${errorStart} must be custom-checked with a function\`);
								}
								const message = shouldBe(propVal);
								if (message) {
									throw new Error(\`\${errorStart} failed a custom property check: \${message}\`);
								}
							}
							break;

						default:
							{
								throw new Error(\`MyReactLib property checker received an invalid second argument: '\${checkType}'\`);
							}
							break;
					}
				}

				__ReactStyles_checkProps() {
					if (ReactStyles._checkPropDisabled) {
						return;
					}

					for (const args of this.__ReactStyles_propsToCheck) {
						this.__ReactStyles_checkProp(...args);
					}
				}

				/* REACT WRAPPER BINDINGS */
				// most wrapper functions just provide error checking to prevent React from crashing completely
				// static bindings
				static __ReactStyles_bindGetDerivedStateFromProps() {
					this.__ReactStyles_origGetDerivedStateFromProps = this.getDerivedStateFromProps;
					this.getDerivedStateFromProps = (props, state) => {
						if (typeof this.__ReactStyles_origGetDerivedStateFromProps === "function") {
							try {
								return this.__ReactStyles_origGetDerivedStateFromProps(props, state);
							} catch (error) {
								try {
									const cons = console;
									cons.logError(error);
								} catch (_) {
									// no console!
								}
								return state;
							}
						}
					};
				}

				// instance bindings
				__ReactStyles_bindWrapperFuncs() {
					this.__ReactStyles_bindRender();
					this.__ReactStyles_bindMakeStyle();
					this.__ReactStyles_bindComponentDidMount();
					this.__ReactStyles_bindShouldComponentUpdate();
					this.__ReactStyles_bindComponentDidUpdate();
					this.__ReactStyles_bindSetState();
					this.__ReactStyles_bindForceUpdate();
				}

				__ReactStyles_bindRender() {
					this.__ReactStyles_origRender = this.render;
					this.render = () => {
						if (typeof this.__ReactStyles_origRender !== "function") {
							throw new Error(\`Component <\${this.componentName} /> must have a render function\`);
						}

						// these are the same, unless fullResult is an array (see below)
						let fullResult;
						try {
							this.__ReactStyles_checkProps(); // checked here because shouldComponentUpdate() is not always run (first render, forceUpdate(), etc)
							fullResult = this.__ReactStyles_origRender();
							if (typeof fullResult !== "object") {
								throw new Error(\`Component <\${this.componentName} />.render() must return a React/JSX representation of a DOM element\`);
							}
						} catch (error) {
							try {
								// avoid console dot warnings
								const cons = console;
								cons.logError(\`(<\${this.componentName} /> render failed!) \${error}\`);
							} catch (_) {
								// do nuthin
							}
							return React.createElement(
								"div",
								{ style: { color: "white", ["background-color"]: "red" } },
								"render error"
							);
						}

						// disables ref-based props for arrays and fragments
						if (Array.isArray(fullResult)) {
							if (this.__ReactStyles_shouldHandleHiddenProp) {
								this.disableHiddenProp(true);
								try {
									const cons = console;
									cons.logWarning(\`Arrays in render() cannot use "hidden" prop; will be disabled (in component '\${this.componentName}')\`);
								} catch (_) {
									// okay, console doesnt exist...
								}
							}
						} else if (fullResult.type === React.Fragment) {
							if (this.__ReactStyles_shouldHandleHiddenProp) {
								this.disableHiddenProp(true);
								try {
									const cons = console;
									cons.logWarning(\`React.Fragments in render() cannot use "hidden" prop; will be disabled (in component '\${this.componentName}')\`);
								} catch (_) {
									// okay, console doesnt exist...
								}
							}
						}

						// represents html element
						if (typeof fullResult.type === "string") {
							if (!fullResult.props.className) {
								fullResult.props.className = this.componentName;
							}

							if (this.props.__ReactStyles_parentClassName) {
								fullResult.props.className += ' ' + this.props.__ReactStyles_parentClassName;
							}
						}
						// represents class component
						else {
								// tells future render to include this class (since it "is" this component, style-wise)
								fullResult.props.__ReactStyles_parentClassName = this.componentName;
								if (this.props.__ReactStyles_parentClassName) {
									fullResult.props.__ReactStyles_parentClassName += ' ' + this.props.__ReactStyles_parentClassName;
								}
							}

						this.__ReactStyles_handleHiddenProp(fullResult);
						return fullResult;
					};
				}

				__ReactStyles_bindMakeStyle() {
					this.__ReactStyles_origMakeStyle = this.makeStyle;
					this.makeStyle = when => {
						if (typeof this.__ReactStyles_origMakeStyle !== "function") {
							return; // no reason to run if there is no makeStyle()
						}

						try {
							const styleRep = this.__ReactStyles_origMakeStyle(when);
							if (typeof styleRep !== "object" || !(styleRep.type === undefined || styleRep.type === "style")) {
								throw new Error(\`\${this.componentName}.makeStyle() must return either an object representing CSS prop-value pairs, or a JSX style element with a single (string) child\`);
							}
							return styleRep;
						} catch (error) {
							try {
								// avoid console dot warnings
								const cons = console;
								cons.logError(\`(<\${this.componentName} /> style-making failed!) \${error}\`);
							} catch (_) {
								// do nuthin
							}
						}
					};
				}

				__ReactStyles_bindComponentDidMount() {
					this.__ReactStyles_origComponentDidMount = this.componentDidMount;
					this.componentDidMount = () => {
						// initialized here so this.state could exist for makeStyle() use
						this.__ReactStyles_initStyle();

						if (typeof this.__ReactStyles_origComponentDidMount === "function") {
							try {
								this.__ReactStyles_origComponentDidMount();
							} catch (error) {
								try {
									const cons = console;
									cons.logError(\`(<\${this.componentName} /> mounting failed!) \${error}\`);
								} catch (_) {
									// welp, guess you wont know
								}
							}
						}
						this.__ReactStyles_updateDynamicStyles();
					};
				}

				__ReactStyles_bindShouldComponentUpdate() {
					this.__ReactStyles_origShouldComponentUpdate = this.shouldComponentUpdate;
					this.shouldComponentUpdate = (nextProps, nextState) => {
						if (typeof this.__ReactStyles_origShouldComponentUpdate === "function") {
							try {
								return nextProps.shouldUpdate || this.__ReactStyles_origShouldComponentUpdate(nextProps, nextState);
							} catch (error) {
								try {
									const cons = console;
									cons.logError(\`(<\${this.componentName} /> should-updating failed!) \${error}\`);
								} catch (_) {
									// welp, guess you wont know
								}
								return false; // dont update on errors
							}
						} else {
								return true; // no checking provided!
							}
					};
				}

				__ReactStyles_bindComponentDidUpdate() {
					this.__ReactStyles_origComponentDidUpdate = this.componentDidUpdate;
					this.componentDidUpdate = () => {
						if (typeof this.__ReactStyles_origComponentDidUpdate === "function") {
							try {
								this.__ReactStyles_origComponentDidUpdate();
							} catch (error) {
								try {
									const cons = console;
									cons.logError(\`(<\${this.componentName} /> updating failed!) \${error}\`);
								} catch (_) {
									// welp, guess you wont know
								}
							}
						}
						this.__ReactStyles_updateDynamicStyles();
					};
				}

				// NOTE: a few notes for this function (its awesome!)
				//  - it wont crash the whole app if either callback errors
				//  - if there are errors (and a console), it will warn on the console
				//  - it is both awaitable and allows a callback as a second argument
				__ReactStyles_bindSetState() {
					this.__ReactStyles_origSetState = this.setState;
					this.setState = (newState = {}, callback = null) => {
						return new Promise((res, rej) => {
							this.__ReactStyles_origSetState((state, props) => {
								if (typeof newState === "function") {
									try {
										return newState(state, props);
									} catch (error) {
										this.__ReactStyles_setStateFail(error);
										rej(error);
										return {};
									}
								} else {
									return newState;
								}
							}, () => {
								if (typeof callback === "function") {
									try {
										callback();
									} catch (error) {
										this.__ReactStyles_setStateFail(error);
										rej(error);
									}
								}
								res(this.state);
							});
						});
					};
				}

				__ReactStyles_setStateFail(error) {
					try {
						// avoid console dot warnings
						const cons = console;
						cons.logError(\`(<\${this.componentName} /> setState failed!) \${error}\`);
					} catch (_) {
						// do nuthin
					}
				}

				__ReactStyles_bindForceUpdate() {
					this.__ReactStyles_origForceUpdate = this.forceUpdate;
					this.forceUpdate = (callback = null) => {
						return new Promise((res, rej) => {
							this.__ReactStyles_origForceUpdate(() => {
								if (typeof callback === "function") {
									try {
										callback();
									} catch (error) {
										this.__ReactStyles_forceUpdateFail(error);
										rej(error);
									}
								}
								res();
							});
						});
					};
				}

				__ReactStyles_forceUpdateFail(error) {
					try {
						// avoid console dot warnings
						const cons = console;
						cons.logError(\`(<\${this.componentName} /> forceUpdate failed!) \${error}\`);
					} catch (_) {
						// do nuthin
					}
				}

				/* CSS STYLE IMPLEMENTATION */
				__ReactStyles_initStyle() {
					const style = this.makeStyle(ReactStyles._makeStyleWhen);
					if (ReactStyles._shouldRenderStyle(this.componentName)) {
						if (style === undefined) {
							// not much to do...
							ReactStyles._renderStyle(this.componentName, '');
						} else if (style.type === "style") {
							try {
								const cons = console; // avoid console dot warnings
								cons.logWarning(\`\${this.componentName}.makeStyle() returned a style element; this is legacy functionality, so it is better to use object notation\`);
							} catch (_) {
								// welp, no console exists...
							}
							ReactStyles._renderStyle(this.componentName, style.props.children);
						} else if (typeof style === "object") {
							const processedStyle = this.__ReactStyles_parseStyle(style, "normalMode");
							ReactStyles._renderStyle(this.componentName, processedStyle);
						}
					}

					// compiles the dynamic styles, but without all the baggy strings (optimization)
					else {
							if (style) {
								const isJSXElement = style.type;
								if (!isJSXElement) {
									this.__ReactStyles_parseStyle(style, "dynamicOnly");
								}
							}
						}
				}

				__ReactStyles_parseStyle(style, mode = "normalMode") {
					return ReactStyles._parseStyleAs(mode, '.' + this.componentName, style, this.__ReactStyles_dynamicStyles);
				}

				// checks if dynamic styles need to be updated, and if so, renders whats needed
				__ReactStyles_updateDynamicStyles() {
					ReactStyles._renderDynamicStyles(this.__ReactStyles_dynamicStyles, this);
					if (typeof this.componentDidUpdateStyle === "function") {
						this.componentDidUpdateStyle();
					}
				}
				forceUpdateStyles() {
					this.__ReactStyles_updateDynamicStyles();
				}

				__ReactStyles_handleHiddenProp(result) {
					if (!this.__ReactStyles_shouldHandleHiddenProp) {
						return;
					}

					const hidingChild = ReactStyles._getChildWithClass(this.componentName, result);
					if (!hidingChild) {
						return;
					}

					if (typeof hidingChild.props.style !== "object" || hidingChild.props.style === null) {
						hidingChild.props.style = {};
					}

					// update built-in hidden prop
					if (this.props.hidden) {
						hidingChild.props.style.display = "none";
					}
				}
			};
		}

		/* RENDER RESULT MANIPULATION */
		static _getChildWithClass(name, result) {
			let children = result; // will be an array somehow by the end of this block
			if (!Array.isArray(result)) {
				if (!result || typeof result !== "object") {
					return null;
				}
				if (typeof result.props.className === "string" && result.props.className.split(' ').includes(name)) {
					return result;
				}

				children = result.props.children;
				if (!Array.isArray(children)) {
					children = [children];
				}
			}

			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				const nextResult = this._getChildWithClass(name, child);
				if (nextResult) {
					return nextResult;
				}
			}

			return null;
		}

		// certain components (like class expressions) dont have names, so this gives them one
		static _getUnnamedComponentName(constructor) {
			if (!this._unnamedComponentList) {
				this._unnamedComponentList = {};
				this._unnamedComponentNameList = {};
			}
			if (!this._unnamedCount) {
				this._unnamedCount = 0;
			}

			if (!this._unnamedComponentList[constructor]) {
				const name = \`UnnamedComponent\${this._unnamedCount++}\`;
				this._unnamedComponentList[constructor] = name;
				this._unnamedComponentNameList[name] = constructor;
			}
			return this._unnamedComponentList[constructor];
		}

		// provides a way to get the original constructor of an unnamed component
		static getUnnamedComponent(n) {
			return this._unnamedComponentNameList[\`UnnamedComponent\${n}\`];
		}

		/* STYLE RENDERING (STATIC) */
		// cache of components that have rendered
		// ReactStyles._stylesToRender{}
		static get _stylesToRender() {
			if (!this.__stylesToRender) {
				this.__stylesToRender = {};
			}
			return this.__stylesToRender;
		}

		// returns if component class has already been rendered before
		static _shouldRenderStyle(componentClass) {
			return this._stylesToRender[componentClass] ? false : true;
		}

		// saves a components style, and tells React to update the main div
		static _renderStyle(componentClass, styleStr) {
			this._stylesToRender[componentClass] = true;
			this._loadStyle(styleStr);
		}

		static _loadStyle(styleStr) {
			// initializing static and dynamic styles...
			if (!this._stylesContainer) {
				// static styles
				this._stylesContainer = document.createElement("div");
				document.head.appendChild(this._stylesContainer);

				// dynamic styles (including themes)
				// NOTE: these can be initialized here because static styles are initialized before dynamic ones
				this._dynamicStylesContainer = document.createElement("div");
				document.head.appendChild(this._dynamicStylesContainer);

				this._dynamicStyleRefs = {};

				// theme styles
				this._themeStylesElem = document.createElement("style");
				document.head.appendChild(this._themeStylesElem);
				if (this._setThemeStylesContainerOnInit) {
					this._themeStylesElem.innerHTML = this._setThemeStylesContainerOnInit;
					delete this._setThemeStylesContainerOnInit;
				}
			}
			if (styleStr) {
				const style = document.createElement("style");
				style.innerHTML = styleStr;
				this._stylesContainer.appendChild(style);
			}
		}

		/* STYLE RENDERING (DYNAMIC) */
		// creates a style element for a single class line
		static _createDynamicStyleElem(classLine) {
			const elem = document.createElement("style");
			this._dynamicStylesContainer.appendChild(elem);
			this._dynamicStyleRefs[classLine] = elem;
			return elem;
		}

		// renders (creating elements if needed) a list of class lines,
		// and only modifies elements when the class lines change
		static _renderDynamicStyles(styleStack, componentRef) {
			if (!this._lastStyleValues) {
				this._lastStyleValues = {};
			}

			let mergedClassLines = {};
			const initStyleStackLength = styleStack.length;
			styleStack = styleStack.concat(this._dynamicThemeStyles || []); // "|| []" in case themes arent initialized yet
			for (let i = 0; i < styleStack.length; i++) {
				const styleData = styleStack[i];
				const { classLine, prop, getValue } = styleData;

				let newVal;
				try {
					newVal = getValue(componentRef);

					// skip the theme when callback does not apply to this component
					if (newVal === ReactStyles._themeSkipped) {
						continue;
					}
				} catch (error) {
					try {
						const cons = console; // avoid... yeah
						if (i >= initStyleStackLength) {
							cons.logError(\`(Theme (for <\${componentRef.componentName} />) style-updating failed!) \${error}\`);
						} else {
							cons.logError(\`(<\${componentRef.componentName} /> style-updating failed!) \${error}\`);
						}
					} catch (_) {
						// no console!
					}
				}

				if (!mergedClassLines[classLine]) {
					mergedClassLines[classLine] = "";
				}

				if (classLine.slice(0, 7) === "@keyfra") {
					mergedClassLines[classLine] += \`\${ReactStyles._parseCSSPropName(prop)} {\${newVal}}\\n\`;
				} else {
					mergedClassLines[classLine] += \`\${ReactStyles._parseCSSPropName(prop)}: \${newVal};\\n\`;
				}
			}

			// applies merged style strings to their corresponding elements
			for (const classLine in mergedClassLines) {
				const props = mergedClassLines[classLine];
				let ref = this._dynamicStyleRefs[classLine];
				if (!ref) {
					ref = this._createDynamicStyleElem(classLine);
				}

				if (props !== this._lastStyleValues[classLine]) {
					ref.innerHTML = \`\${classLine} {\${props}}\`;
					this._lastStyleValues[classLine] = props;
				}
			}
		}

		/* COMPONENT-CSS FUNCTIONS */
		// reruns the animation defined in css
		// NOTE: must be given the css class name that defines an "animation-name" property
		static rerunAnimationOn(elem, className) {
			elem.classList.remove(className);
			void elem.offsetWidth;
			elem.classList.add(className);
		}

		static _makeStyleWhen(subclass) {
			return "when=" + subclass;
		}

		// given a css class line and an object representing style, this generates a string full of css class rules
		// NOTE: "dynamicOnly" can be passed as the first argument to avoid constructing strings and only initialize dynamic function constructs (optimization)
		// NOTE: "themeMode" processes as a theme, and allows use of themeClassName
		static _parseStyleAs(mode, classLine, styleRep, dynStyleStack, themeClassName = null) {
			if (typeof styleRep !== "object") {
				return ""; // pretty css-like way to do it, right?
			}

			const whenKey = 'when=';
			// these strings will only be modified if the mode !== "dynamicOnly"
			let styleContent = "";
			let subClassStr = "";
			let childClassStr = "";

			for (const prop in styleRep) {
				const value = styleRep[prop];

				// if it is a when() subclass...
				if (prop.slice(0, whenKey.length) === whenKey) {
					const whenProp = prop.slice(whenKey.length);
					let subClassLine = classLine;
					// forces props that start with a letter to be a '.' class
					const code = whenProp.charCodeAt(0);
					if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
						subClassLine += '.';
					}
					subClassLine += whenProp;

					if (mode === "dynamicOnly") {
						this._parseStyleAs(mode, subClassLine, value, dynStyleStack, themeClassName);
					} else {
						subClassStr += this._parseStyleAs(mode, subClassLine, value, dynStyleStack, themeClassName);
					}
				}

				// if it is a child class...
				else if (typeof value === "object") {
						// special: @keyframes
						if (prop[0] === '@') {
							if (mode === "dynamicOnly") {
								this._parseKeyFrames(mode, prop, value, dynStyleStack);
							} else {
								childClassStr += this._parseKeyFrames(mode, prop, value, dynStyleStack);
							}
						}

						// special: raw line definition
						else if (prop[0] === '=') {
								if (mode === "dynamicOnly") {
									this._parseStyleAs(mode, prop.slice(1), value, dynStyleStack, themeClassName);
								} else {
									childClassStr += this._parseStyleAs(mode, prop.slice(1), value, dynStyleStack, themeClassName);
								}
							}

							// regular subclass
							else {
									let childSep = ' ';
									// if first character is a capital letter, its a subclass name (allows using things like button and *)
									const code = prop.charCodeAt(0);
									if (code >= 65 && code <= 90) {
										childSep += '.';
									}

									const childClassLine = classLine + childSep + prop;
									if (mode === "dynamicOnly") {
										this._parseStyleAs(mode, childClassLine, value, dynStyleStack, themeClassName);
									} else {
										childClassStr += this._parseStyleAs(mode, childClassLine, value, dynStyleStack, themeClassName);
									}
								}
					}

					// if it is a dynamic/updatable property...
					else if (typeof value === "function") {
							if (mode === "themeMode") {
								const getValue = ref => {
									// for themes, callbacks should only be called on the correct components
									if (ref.constructor.name === themeClassName) {
										return value(ref);
									} else {
										return this._themeSkipped;
									}
								};

								// keeps track of dynamic theme styles to delete when a new theme is selected
								dynStyleStack.push({ classLine, prop, getValue });
							} else {
								dynStyleStack.push({ classLine, prop, getValue: value });
							}
						}

						// if it is a regular css property
						else {
								if (mode !== "dynamicOnly") {
									const propName = this._parseCSSPropName(prop);
									styleContent += \`\${propName}: \${value};\\n\`;
								}
							}
			}

			if (mode === "dynamicOnly") {
				return;
			}
			// increases specificity to override component makeStyle() statements
			else if (mode === "themeMode") {
					return \`html:not(.__THIS_INCREASES_SPECIFICITY__) \${classLine} {\\n\${styleContent}}\\n\${subClassStr}\${childClassStr}\`;
				} else {
					return \`\${classLine} {\\n\${styleContent}}\\n\${subClassStr}\${childClassStr}\`;
				}
		}

		// changes "backgroundColor" to "background-color"
		static _parseCSSPropName(name) {
			let newName = "";
			for (let i = 0; i < name.length; i++) {
				const char = name[i];
				if (char === char.toUpperCase()) {
					newName += '-' + char.toLowerCase();
				} else {
					newName += char;
				}
			}
			return newName;
		}

		// creates strings from keyframe object representations
		static _parseKeyFrames(mode, frameLine, value, dynStyleStack) {
			if (typeof value !== "object") {
				return "";
			}

			let frameRules = "";
			let dynFrameRules = [];
			let useDynRules = false;
			for (let frameTime in value) {
				const frameTimeRules = value[frameTime];
				const frameTimeInt = parseInt(frameTime);
				if (frameTimeInt || frameTimeInt === 0) {
					frameTime = frameTimeInt + '%';
				}

				let rulesStr = "";
				let rulesFuncPairs = [];
				for (const ruleProp in frameTimeRules) {
					const ruleVal = frameTimeRules[ruleProp];
					if (typeof ruleVal === "function") {
						useDynRules = true;
					}

					if (!useDynRules && mode !== "dynamicOnly") {
						rulesStr += \`\${ruleProp}: \${ruleVal};\\n\`;
					}
					// NOTE: must keep track in case dynamic rules must be used in later loops
					rulesFuncPairs.push({ prop: ruleProp, value: ruleVal });
				}

				if (!useDynRules && mode !== "dynamicOnly") {
					frameRules += \`\${frameTime} {\\n\${rulesStr}}\\n\`;
				}

				const rulesFunc = ref => {
					let propsStr = "";
					for (let i = 0; i < rulesFuncPairs.length; i++) {
						let { prop, value } = rulesFuncPairs[i];
						if (typeof value === "function") {
							value = value(ref);
						}
						propsStr += \`\${prop}: \${value};\\n\`;
					}
					return propsStr;
				};
				dynFrameRules.push({
					classLine: frameLine,
					prop: frameTime,
					getValue: rulesFunc
				});
			}

			if (!useDynRules) {
				return \`\${frameLine} {\\n\${frameRules}}\\n\`;
			} else {
				for (let i = 0; i < dynFrameRules.length; i++) {
					dynStyleStack.push(dynFrameRules[i]);
				}
				return '';
			}
		}

		/* THEME FUNCTIONS */
		// creates a theme preset
		// NOTE: names for the first layer of objects should be
		// names of components, NOT abstract CSS class names
		static registerTheme(name, styleRepOrCallback) {
			if (!this._registeredThemes) {
				this._registeredThemes = {};
			}

			if (name.includes(',')) {
				throw new Error(\`Theme names cannot contain ',' (in '\${name}')\`);
			}

			let styleRep = styleRepOrCallback;
			if (typeof styleRep === "function") {
				styleRep = styleRep(ReactStyles._makeStyleWhen);
			}

			const extStr = styleRep.extends;
			if (typeof extStr === "string") {
				delete styleRep.extends;
				this._mixinTheme(styleRep, this._registeredThemes[extStr]);
			}

			this._registeredThemes[name] = styleRep;
		}

		static get registeredThemes() {
			let themes = [];
			for (const themeName in this._registeredThemes) {
				themes.push(themeName);
			}
			return themes;
		}

		// returns a theme as a css style string
		static _parseTheme(styleRep) {
			let styleStr = "";
			for (const prop in styleRep) {
				let boundCompName = prop;
				const isComp = this._evalCheckIsComponent(prop);
				if (!isComp) {
					boundCompName = "";
					if (!this._themeClassCheckDisabled) {
						try {
							const cons = console;
							cons.logWarning(\`Selected theme root property '\${prop}' is not a ReactStyles.Component (some features will not work properly)\`);
						} catch (_) {
							// do nuthin
						}
					}
				}

				const value = styleRep[prop];
				if (typeof value === "object") {
					const notStr = ":not(.__THIS_INCREASES_SPECIFICITY__)";
					styleStr += this._parseStyleAs("themeMode", '.' + prop + notStr, value, this._dynamicThemeStyles, boundCompName);
				}
			}
			return styleStr;
		}

		static _evalCheckIsComponent(name) {
			try {
				const result = eval(name);
				if (result && (result.prototype instanceof this.Component || result.prototype instanceof this.PureComponent)) {
					return result;
				}
				return null;
			} catch (error) {
				if ((error + '').includes("access lexical declaration")) {
					return name;
				}
				return null;
			}
		}

		static get _themeSkipped() {
			if (!this.__themeSkipped) {
				this.__themeSkipped = Symbol();
			}
			return this.__themeSkipped;
		}

		static get selectedTheme() {
			return this._selectedTheme;
		}
		static set selectedTheme(names) {
			if (!(names instanceof Array)) {
				names = [names];
			}
			this._selectedTheme = names;

			// resets previous dynamic properties defined in themes
			if (this._dynamicStyleRefs) {
				// (in case there hasnt been a render yet)
				// "|| []" is used since this also initializes this._dynamicThemeStyles
				for (let i = 0; i < (this._dynamicThemeStyles || []).length; i++) {
					const { classLine } = this._dynamicThemeStyles[i];
					const ref = this._dynamicStyleRefs[classLine];
					if (ref) {
						// is undefined when classLine is tracked but theme reselected without updating at some point
						ref.innerHTML = "";
					}
				}
			}
			this._dynamicThemeStyles = [];

			let newTheme = {};
			for (let i = 0; i < names.length; i++) {
				const name = names[i];
				const theme = this._registeredThemes[name];
				if (theme) {
					this._mixinTheme(newTheme, theme);
				}
			}

			const finalStyle = this._parseTheme(newTheme);
			if (this._themeStylesElem) {
				this._themeStylesElem.innerHTML = finalStyle;
			} else {
				this._setThemeStylesContainerOnInit = finalStyle;
			}
		}

		static _combineThemes(...themes) {
			let theme = {};
			for (let i = 0; i < themes.length; i++) {
				this._mixinTheme(theme, themes[i]);
			}
			return theme;
		}
		// modifies theme to include undefined properties from nextTheme, without
		// modifying nextTheme
		static _mixinTheme(theme, nextTheme) {
			if (typeof nextTheme !== "object") {
				return;
			}

			for (const prop in nextTheme) {
				const value = nextTheme[prop];
				if (!value) {
					continue;
				}

				const currValue = theme[prop];
				if (!currValue) {
					if (typeof value === "object") {
						theme[prop] = {};
						this._mixinTheme(theme[prop], value);
					} else {
						theme[prop] = value;
					}
				} else if (typeof currValue === "object") {
					this._mixinTheme(currValue, value); // currValue can be modified
				}
			}
		}

		// register a name for a css property
		static registerPreset(name, valueObj, mode = "warn") {
			const currVal = this._registeredPresets[name];
			if (!currVal || mode === "overwrite") {
				if (typeof valueObj === "string") {
					const value = valueObj;
					valueObj = { value, type: "prop" };
				} else if (!valueObj.type) {
					valueObj.type = "prop";
				} else if (!["prop", "color"].includes(valueObj.type)) {
					throw new Error(\`Cannot register preset of invalid type '\${valueObj.type}'\`);
				}
				this._registeredPresets[name] = valueObj;
			} else if (mode === "warn") {
				try {
					const cons = console;
					cons.logWarning(\`ReactStyles preset '\${name}' already registered; pass "overwrite" as the third argument to override\`);
				} catch (_) {
					// kay, no displaying of logs for you..
				}
			} else if (mode === "nowarn") {
				// no warn, no overwrite
			}
		}

		// get the css-ready property string from a preset name
		static getPreset(name, options = {}) {
			const value = this._registeredPresets[name];
			if (!value) {
				throw new Error(\`ReactStyles preset '\${name}' does not exist\`);
			}

			let valueStr;
			if (value.type === "color") {
				if (typeof options.alpha === "number" || typeof options.alpha === "string") {
					valueStr = \`rgba(\${value.value}, \${options.alpha})\`;
				} else {
					valueStr = \`rgb(\${value.value})\`;
				}
			} else if (value.type === "prop") {
				valueStr = value.value;
			}

			return valueStr;
		}

		// generates a "blueprint" theme that can be filled with values
		static registerThemeFromBase(name, styleRepCallback, fillDefs) {
			if (typeof styleRepCallback !== "function") {
				throw new Error(\`ReactStyles can only register a theme from a base using a callback (as the second argument)\`);
			}

			this.registerTheme(name, styleRepCallback(fillDefs, ReactStyles._makeStyleWhen));
		}

		static get _registeredPresets() {
			if (!this.__registeredPresets) {
				this.__registeredPresets = {};
			}
			return this.__registeredPresets;
		}

		static isColorDark(preset) {
			let rgbStr = this.getPreset(preset);

			let throwErr = false;
			if (rgbStr.slice(0, 4) !== "rgb(") {
				throwErr = true;
			}

			rgbStr = rgbStr.slice("rgb(".length, rgbStr.lastIndexOf(')'));
			const [red, green, blue] = rgbStr.split(',').map(str => {
				const asInt = parseInt(str);
				if (!asInt || throwErr) {
					throw new Error(\`ReactStyles preset '\${preset}' is not a valid color preset\`);
				}
				return asInt;
			});

			const hsp = Math.sqrt(0.299 * red ** 2 + 0.587 * green ** 2 + 0.144 * blue ** 2);
			return hsp < 256 / 2;
		}
	}

	/* MODULE INFO:
 	Originally designed for the Code Writer (and later taken out),
 	this is an executor that provides an "eval" function where variables
 	accessible from the higher scope can be overridden by an object
 	representing a desired "global context".
 */

	class SaferCodeExecuter {
		constructor(context = {}) {
			this.setGlobalContext(context);
		}

		setGlobalContext(context) {
			let globalsMap = this._redefineGlobalWindow(context);

			let globalParamNames = [];
			let globalParamVals = [];
			for (let prop in globalsMap) {
				globalParamNames.push(prop);
				globalParamVals.push(globalsMap[prop]);
			}

			const comma = globalParamNames.length > 0 ? ', ' : '';
			const unboundEval = eval(\`(function (\${globalParamNames}\${comma}_c_o_d_e_) {eval(_c_o_d_e_)})\`);
			this._boundEval = unboundEval.bind(undefined, ...globalParamVals);
		}

		execute(code) {
			this._boundEval(code);
		}

		_redefineGlobalWindow(context) {
			let redefinedGlobals = {};
			for (let prop in window) {
				if (!this._invalidFuncArgName(prop)) {
					redefinedGlobals[prop] = undefined;
				}
			}
			for (let prop in context) {
				redefinedGlobals[prop] = context[prop];
			}
			return redefinedGlobals;
		}

		_invalidFuncArgName(str) {
			str += "1"; // turns "0" to truthy value below
			const startsWithNumber = parseInt(str) ? true : false;
			const hasBadChar = str.includes('-');
			return startsWithNumber || hasBadChar;
		}
	}

	/* MODULE INFO:
 	Provides a higher-level framework to interact with the browsers
 	localStorage object. This includes representing an entire object
 	as a single property in localStorage, which can be modified
 	immediately yet also provide safety from crashes due to saving
 	to localStorage on a delay.
 */

	class StorageRegistry {
		constructor(storageKey) {
			if (!storageKey || typeof storageKey !== "string") {
				throw new Error(\`StorageRegistry must be created with a non-null string (got '\${storageKey}')\`);
			}

			this._strSep = '-' + ';' + '-'; // using '+' allows loading this file without confusing the parser 
			this._pairSep = '-' + ',' + '-';
			this._emptyString = "__empty-string__";

			this._storageKey = storageKey;
			this._updateQueued = false;
			this._reset = false;
			this._getStoredStrs();
		}

		onStoreFinish() {
			// overridden by implementation
		}
		onStoreFull() {
			// overridden by implementation
		}
		onStoreError(error) {
			// overridden by implementation
		}

		get keys() {
			let keys = [];
			for (let key in this._strs) {
				keys.push(key);
			}
			return keys;
		}

		get empty() {
			return this._empty;
		}
		get numStored() {
			return this.keys.length;
		}

		getStoredStr(key) {
			let str = this._strs[key];
			if (str === this._emptyString) {
				str = "";
			}
			return str;
		}

		// NOTE: key/str pair is stored immediately, but localStorage is updated asyncronously
		setStoredStr(key, str) {
			if (key === '') {
				throw new Error(\`Cannt set empty string ('') as storage key\`);
			}
			if (typeof str !== "string") {
				throw new Error(\`Cannot set storage key '\${key}' to non-string '\${str}'\`);
			}
			if (str === this._emptyString) {
				throw new Error(\`Registry cannot store reserved string '\${str}'\`);
			}

			if (str.includes(this._pairSep) || str.includes(this._strSep)) {
				throw new Error(\`Registry cannot store strings with reserved substrings '\${this._pairSep}' or '\${this._strSep}'\`);
			}

			if (str === "") {
				str = this._emptyString;
			}

			this._strs[key] = str;
			this._empty = false;

			if (!this._updateQueued) {
				// delay is a security and optimization measure (mostly for async functions);
				// its less likely to save "crashing data" and batches more set requests together
				setTimeout(() => this._updateStorage(), 100);
				this._updateQueued = true;
			}
		}

		reset(mode = "") {
			this._empty = true;
			this._strs = {};
			if (mode === "hard") {
				localStorage.removeItem(this._storageKey);
			}
		}

		_getStoredStrs() {
			const storageStr = localStorage[this._storageKey] || "";
			this._strs = {};

			if (!storageStr) {
				this._empty = true;
				return;
			}
			this._empty = false;

			for (let pair of storageStr.split(this._strSep)) {
				let [key, str] = pair.split(this._pairSep);
				this._strs[key] = str;
			}
		}

		_updateStorage() {
			this._updateQueued = false;

			let storageList = [];
			for (const key in this._strs) {
				const str = this._strs[key];
				const pair = \`\${key}\${this._pairSep}\${str}\`;
				storageList.push(pair);
			}

			try {
				localStorage[this._storageKey] = storageList.join(this._strSep);
				this.onStoreFinish();
			} catch (error) {
				const errorStr = error + "";
				if (errorStr.includes("QuotaExceeded")) {
					this.onStoreFull();
				} else {
					this.enStoreError(error);
				}
			}
		}
	}

	/* MODULE INFO:
 	Provides some tools to help emulate "typing on a keyboard".
 */

	class TextOperator {
		static get spacesPerIndent() {
			return 3;
		}

		constructor(workingStr, arrOrStart = workingStr.length, end = arrOrStart) {
			this._workingStr = workingStr;
			this._selection = new TextOperator.Selection(arrOrStart, end);
		}

		toString() {
			return "[object TextOperator]";
		}

		reset(toStr = '', arrOrStart = toStr.length, end = arrOrStart) {
			this._workingStr = toStr;
			this._selection = new TextOperator.Selection(arrOrStart, end);
		}

		get result() {
			return this._workingStr;
		}

		getSlice(...args) {
			// reverse if sliceFrom > sliceTo
			if (args[1] && args[0] > args[1]) {
				let oldArgs0 = args[0];
				args[0] = args[1];
				args[1] = oldArgs0;
			}

			// optimization for single-character requests
			if (args[0] === args[1] - 1) {
				return this._workingStr[args[0]];
			} else {
				return this._workingStr.slice(...args);
			}
		}

		get selection() {
			return this._selection;
		}
		set selection(pair) {
			this._selection = new TextOperator.Selection(pair);
		}
		get cursor() {
			return this.selection.start;
		}
		set cursor(val) {
			this.selection = [val, val];
		}

		get selectedText() {
			return this.getSlice(...this.selection.asArray());
		}
		set selectedText(newText) {
			this.insertOver(newText, ...this.selection.asArray());
		}

		getLineStart(idx) {
			const afterStart = () => idx > 0;
			const beforeIsNewline = () => this._workingStr[idx - 1] === "\\n";
			while (afterStart() && !beforeIsNewline()) {
				idx--;
			}
			return idx;
		}
		nextLineStart(idx) {
			const isNewline = () => this._workingStr[idx] === "\\n";
			const beforeEnd = () => idx < this._workingStr.length - 1;
			while (!isNewline() && beforeEnd()) {
				idx++;
			}
			return idx < this._workingStr.length ? idx + 1 : this._workingStr.length;
		}

		numIndentsOnLine(idx, tabChars = '\\t') {
			idx = this.getLineStart(idx);
			if (!(tabChars instanceof Array)) {
				tabChars = [tabChars];
			}

			const { spacesPerIndent } = TextOperator;

			let count = 0;
			const isTabIndent = () => {
				for (let tabChar of tabChars) {
					if (this._workingStr.slice(idx, idx + tabChar.length) === tabChar) {
						return tabChar.length;
					}
				}
				return 0;
			};
			const isSpaceIndent = () => this._workingStr.slice(idx, idx + spacesPerIndent) === " ".repeat(spacesPerIndent);
			while (isTabIndent() || isSpaceIndent()) {
				let tabLength = isTabIndent();
				if (tabLength) {
					idx += tabLength;
				} else {
					idx += spacesPerIndent;
				}
				++count;
			}

			return count;
		}

		findNext(substr, startAt = 0) {
			return this._workingStr.indexOf(substr, startAt);
		}
		findAll(substr) {
			let foundAt = [];
			for (let idx = this.findNext(substr); idx !== -1; idx = this.findNext(substr, idx + 1)) {
				foundAt.push(idx);
			}
			return foundAt;
		}

		findNextBetween(startsWith, endsWith, startAt = 0) {
			const startsWithIdx = this.findNext(startsWith, startAt);
			if (startsWithIdx === -1) {
				return [-1, -1];
			}
			const betweenStart = startsWithIdx + startsWith.length;
			const betweenEnd = this.findNext(endsWith, betweenStart);
			return [betweenStart, betweenEnd];
		}

		findAllBetween(startsWith, endsWith) {
			let result = [];
			let startAt = 0;
			while (startAt < this._workingStr.length) {
				const range = this.findNextBetween(startsWith, endsWith, startAt);
				if (range[0] === -1 || range[1] === -1) {
					break;
				}

				result.push(range);
				startAt = range[1] + endsWith.length;
			}
			return result;
		}

		insertOver(str, replaceFrom, replaceTo = replaceFrom) {
			if (replaceFrom > replaceTo) {
				let oldFrom = replaceFrom;
				replaceFrom = replaceTo;
				replaceTo = oldFrom;
			}
			this._workingStr = this._workingStr.slice(0, replaceFrom) + str + this._workingStr.slice(replaceTo);
			this.cursor = replaceFrom + str.length;
		}

		findAndReplace(find, replace) {
			let startAt = 0;
			while (startAt < this._workingStr.length) {
				const from = this._workingStr.indexOf(find, startAt);
				if (from === -1) {
					break;
				}
				const to = from + find.length;
				this.insertOver(replace, from, to);
				startAt = to + 1;
			}
		}

		pairOf(char) {
			const pairs = {
				'(': ')', ')': '(',
				'[': ']', ']': '[',
				'{': '}', '}': '{',
				'<': '>', '>': '<',
				'"': '"', "'": "'", '\\\`': '\\\`'
			};
			return pairs[char];
		}

		// class TextOperator.Selection
		static get Selection() {
			if (!TextOperator._Selection) {
				TextOperator._Selection = class {
					constructor(arrOrStart, end = arrOrStart) {
						let start;
						if (arrOrStart instanceof Array || arrOrStart instanceof TextOperator.Selection || typeof arrOrStart[1] === "number") {
							start = arrOrStart[0];
							end = arrOrStart[1];
						} else if (typeof arrOrStart === 'number' && typeof end === 'number') {
							start = arrOrStart;
						} else {
							throw new Error(\`Cannot create selection from "(\${arrOrStart}, \${end})"\`);
						}

						this[0] = start;
						this[1] = end;

						const _this = this;
						this._asSorted = {
							toString() {
								return _this.toString() + " (sorted, read-only)";
							},

							get direction() {
								return "forward";
							},
							get sorted() {
								return this;
							},

							get [0]() {
								if (_this[0] > _this[1]) {
									return _this[1];
								}
								return _this[0];
							},
							get [1]() {
								if (_this[0] > _this[1]) {
									return _this[0];
								}
								return _this[1];
							},

							get start() {
								return this[0];
							},
							get end() {
								return this[1];
							},

							asArray() {
								if (_this[0] > _this[1]) {
									return [_this[1], _this[0]];
								}
								return [_this[0], _this[1]];
							}
						};
					}

					toString() {
						return \`[object TextOperator.Selection(\${this.start}, \${this.end})]\`;
					}

					asArray() {
						return [this[0], this[1]];
					}

					get direction() {
						// for use with textareas
						if (this[0] > this[1]) {
							return "backward";
						} else {
							return "forward";
						}
					}

					get sorted() {
						// NOTE: originally created new sorted Selection objects, however a
						// faster variation was needed for the <CodeBox /> component
						return this._asSorted;
					}

					get start() {
						return this[0];
					}
					set start(val) {
						if (typeof val !== "number") {
							throw new Error(\`Invalid selection start value "\${val}"\`);
						}
						this[0] = val;
					}

					get end() {
						return this[1];
					}
					set end(val) {
						if (typeof val !== "number") {
							throw new Error(\`Invalid selection end value "\${val}"\`);
						}
						this[1] = val;
					}
				};
			}
			return TextOperator._Selection;
		}
	}

	/* MODULE INFO:
 	Custom built to give the ability to run arbitrary pairs of undo/redo
 	functions, and places them on a stack to be run just like Ctrl-Z!
 */

	class UndoHandler {
		constructor(limit = 9999) {
			this._fnStack = [];
			this._undoPtr = 0;
			this._limit = limit;
		}

		recordAction(func, undoFunc, perform = true) {
			this._forgetUndos();

			const data = { undo: undoFunc, redo: func };
			this._fnStack.unshift(data);
			this._keepLimit();

			if (perform) {
				func();
			}
		}

		undo() {
			if (this._undoPtr < this._fnStack.length) {
				this._fnStack[this._undoPtr++].undo();
			}
		}

		redo() {
			if (this._undoPtr > 0) {
				this._fnStack[--this._undoPtr].redo();
			}
		}

		_keepLimit() {
			if (this._fnStack.length > this._limit) {
				this._fnStack = this._fnStack.slice(0, this._limit);
			}
		}

		_forgetUndos() {
			if (this._undoPtr > 0) {
				this._fnStack = this._fnStack.slice(this._undoPtr);
				this._undoPtr = 0;
			}
		}
	}

	/* MODULE INFO:
 	Last updated for:
 		2020-11-10
 	21:29
 	- Fixing a bug where one could "close" a popup before it "opened"
 	
 		2020-10-29
 	15:00
 	- Restricting white color from "*" to non-text-input elements
 	
 		2020-10-24
 	09:57
 	- Adding onAnimationEnd() target check
 	
 		2020-10-22
 	13:48
 	- Adding zIndex to popup screen makeStyle() to force to front 
 	
 		2020-10-20
 	21:18
 	- Adding onKeyDown support for input fields
 	14:52
 	- Removing margins on divs/spans that are PopupBox children
 	
 		2020-10-19
 	21:52
 	- Allowing optional content generation for custom prompts
 	- Fixing popup children not being centered
 	- Adding default popup children colors/styles
 	
 		2020-10-13
 	17:02
 	- Disabling scroll for elements "underneath" popup
 	
 		2020-10-03
 	21:05
 	- Adding POPUP.createCustom()
 	20:12
 	- Formatting module info
 	- Adding [Enter] support for alerts
 */

	// all popup functions accept "content" as the first argument; this can be a string
	// or an object containing {title, subtitle} strings
	const POPUP = {
		// just accepts content
		async alert(content) {
			const submitRef = React.createRef();
			const contentElems = this._makeContent(content);
			contentElems.push(React.createElement(
				PopupButtonList,
				null,
				React.createElement(
					PopupButton,
					{ ref: submitRef, onClick: () => this.triggerClose("okay") },
					"Okay"
				)
			));

			return this._queueRenderContent(contentElems, submitRef);
		},

		// inputType can either be "single" or an array of "input" and "text"
		// initInputText can be a single string or an array of strings (must be the same length as the number of input types)
		async prompt(content, initInputText = "", inputType = "single") {
			if (inputType === "single") {
				if (typeof initInputText !== "string") {
					throw new Error("POPUPS.prompt() second argument must be a string with third argument 'single'");
				}
				inputType = ["input"];
				if (typeof initInputText === "string") {
					initInputText = [initInputText];
				} else {
					throw new Error("POPUPS.prompt() second argument must be a string when third argument is 'single'");
				}
			} else if (!(inputType instanceof Array)) {
				throw new Error("POPUPS.prompt() third argument accepts only 'single' or an array of strings (must contain only 'text' or 'input')");
			} else if (!(initInputText instanceof Array)) {
				throw new Error("POPUPS.prompt() second argument must be an array if third argument is an array )");
			}

			let inputs = [];
			let inputRefs = [];
			for (let i = 0; i < inputType.length; i++) {
				const text = initInputText[i];
				const type = inputType[i];

				const ref = React.createRef();
				const focusNext = () => {};
				let input;
				if (type === "input") {
					input = React.createElement(
						PopupInputField,
						{ ref: ref },
						text || ""
					);
				} else if (type === "text") {
					input = React.createElement(
						PopupTextField,
						{ ref: ref },
						text || ""
					);
				} else {
					throw new Error("POPUP.prompt() third argument arrays must only contain 'text' or 'input' as values");
				}

				inputs.push(input);
				inputRefs.push(ref);
			}

			const getAllInputs = () => {
				if (inputRefs.length === 1) {
					return inputRefs[0].current.value;
				} else {
					return inputRefs.map(ref => ref.current.value);
				}
			};

			const submitRef = React.createRef();
			const contentElems = this._makeContent(content).concat(inputs);
			contentElems.push(React.createElement(
				PopupButtonList,
				null,
				React.createElement(
					PopupButton,
					{ onClick: () => this.triggerClose(null) },
					"Cancel"
				),
				React.createElement(
					PopupButton,
					{ ref: submitRef, onClick: () => this.triggerClose(getAllInputs()) },
					"Okay"
				)
			));

			return this._queueRenderContent(contentElems, submitRef);
		},

		// type controls the button names
		async confirm(content, type = "yes") {
			let affirmative, negative;
			switch (type) {
				default:
				case "yes":
					{
						affirmative = "Yes";
						negative = "No";
					}
					break;

				case "continue":
					{
						affirmative = "Continue";
						negative = "Cancel";
					}
					break;

				case "confirm":
					{
						affirmative = "Confirm";
						negative = "Cancel";
					}
					break;
			}

			const contentElems = this._makeContent(content);
			contentElems.push(React.createElement(
				PopupButtonList,
				null,
				React.createElement(
					PopupButton,
					{ onClick: () => this.triggerClose(false) },
					negative
				),
				React.createElement(
					PopupButton,
					{ onClick: () => this.triggerClose(true) },
					affirmative
				)
			));

			return this._queueRenderContent(contentElems);
		},

		createCustom(afterContentGenerated, name = "", useContent = true) {
			const func = async (content, ...args) => {
				let contentElems, submitRef;
				if (useContent) {
					contentElems = this._makeContent(content);
					submitRef = afterContentGenerated(contentElems, ...args);
				} else {
					contentElems = [];
					submitRef = afterContentGenerated(contentElems, content, ...args); // use content as an argument
				}

				return this._queueRenderContent(contentElems, submitRef);
			};

			if (name) {
				this[name] = func;
			}
			return func;
		},

		triggerClose(val) {
			const resolveRef = this._renderQueue[0].resolveRef;
			const resolve = resolveRef.resolve;
			resolveRef.resolve = () => {}; // resets so resolve is only called once (optimization...?)

			this._renderScreenRef.current.close();
			// resolves after value to allow animation to start first (visual optimization!)
			setTimeout(() => resolve(val));
		},

		_createPopupDiv() {
			const div = document.createElement('div');
			document.body.appendChild(div);
			return div;
		},

		_onPopupClose(rootDiv) {
			document.body.removeChild(rootDiv);
			this._renderQueue.shift();
			if (this._renderQueue.length > 0) {
				this._renderFirstInQueue();
			}
		},

		_makeContent(content) {
			if (typeof content === "string") {
				return [React.createElement(
					PopupTitle,
					null,
					content
				), React.createElement(PopupSpacer, null)];
			} else if (typeof content === "object") {
				const { title, subtitle } = content;
				return [React.createElement(
					PopupTitle,
					null,
					title
				), React.createElement(
					PopupSubtitle,
					null,
					subtitle
				), React.createElement(PopupSpacer, null)];
			} else {
				throw new Error(\`Invalid popup content '\${content}'; expected "string" or object with {title, subtitle}\`);
			}
		},

		_renderQueue: [],
		_renderScreenRef: React.createRef(),
		_queueRenderContent(content, submitRef = null) {
			return new Promise(resolve => {
				const resolveRef = { resolve // allows it to be overridden later
				};const rootDiv = this._createPopupDiv();
				this._renderQueue.push({ content, rootDiv, resolveRef, submitRef });
				if (this._renderQueue.length === 1) {
					this._renderFirstInQueue();
				}
			});
		},
		_renderFirstInQueue() {
			const { content, rootDiv, resolveRef, submitRef } = this._renderQueue[0];
			ReactDOM.render(React.createElement(
				PopupScreen,
				{
					ref: this._renderScreenRef,
					onCloseStart: () => resolveRef.resolve(),
					onClose: () => this._onPopupClose(rootDiv)
				},
				React.createElement(
					PopupBox,
					{ submitButtonRef: submitRef },
					content
				)
			), rootDiv);
		}
	};

	class PopupScreen extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				closing: false,
				opened: false
			};

			const check = this.addCheckForProp;
			check("onClose", "possible-typeof", "function");
			check("onCloseStart", "possible-typeof", "function");
		}

		makeStyle(when) {
			return {
				position: "absolute",
				top: "0px",
				left: "0px",
				zIndex: 99999999,

				width: "100vw",
				height: "100vh",
				backgroundColor: "rgba(2, 0, 12, 0.55)", // STYLE_PRESETS.colorAlpha("activeShadow", 0.55)

				display: "flex",
				justifyContent: "center",
				alignItems: "center",
				flexFlow: "column nowrap",

				[when("opening")]: {
					animation: "PopupFadeInAnimation 0.22s",

					PopupBox: {
						animation: "PopupOpenAnimation 0.22s"
					},
					"@keyframes PopupOpenAnimation": {
						from: {
							transform: "scale(0.8)"
						}
					}
				},
				"@keyframes PopupFadeInAnimation": {
					from: {
						opacity: 0
					}
				},

				[when("closing")]: {
					animation: "PopupFadeOutAnimation 0.22s",
					opacity: 0.5, // just a reminder to remove it on closing!

					PopupBox: {
						animation: "PopupCloseAnimation 0.22s"
					},
					"@keyframes PopupCloseAnimation": {
						to: {
							transform: "scale(0.8)"
						}
					}
				},
				"@keyframes PopupFadeOutAnimation": {
					from: {
						opacity: 1
					},
					to: {
						opacity: 0
					}
				},

				"*": {
					boxSizing: "border-box",

					[when(":focus")]: {
						outline: "none"
					},

					[when("::-moz-focus-inner")]: {
						border: "none"
					}
				}
			};
		}

		render() {
			return React.createElement(
				"div",
				{
					className: \`PopupScreen \${this._getAnimationClass()}\`,
					onAnimationEnd: event => {
						if (!event.target.classList.contains("PopupScreen")) {
							return;
						}

						if (!this.state.opened) {
							this.setState({ opened: true });
						} else if (this.state.closing) {
							this.props.onClose();
						}
					},
					onClick: event => {
						event.stopPropagation();
						this.close();
					}
				},
				this.props.children
			);
		}

		close() {
			if (this.state.opened) {
				this.setState({ closing: true });
				this.props.onCloseStart();
			}
		}

		_getAnimationClass() {
			if (this.state.closing) {
				return "closing";
			} else if (!this.state.opened) {
				return "opening";
			}
		}
	}

	class PopupBox extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this._selfFocusRef = React.createRef();

			const check = this.addCheckForProp;
			check("submitButtonRef", "possible-typeof", "object");
		}

		makeStyle(when) {
			return {
				width: "280px",
				minHeight: "100px",
				padding: "5px 10px",

				backgroundColor: "rgb(37, 37, 48)", // STYLE_PRESETS.color("deepNavy")
				border: "none",
				borderRadius: "15px",

				display: "flex",
				flexFlow: "column nowrap",
				justifyContent: "center",
				alignItems: "center",

				"*": {
					[when(":not(.PopupTextField):not(.PopupInputField)")]: {
						color: "rgb(200, 200, 200)" // STYLE_PRESETS.color("softWhite")
					},
					[when(":not(div):not(span)")]: {
						margin: "5px"
					}
				}
			};
		}

		render() {
			this._shouldSubmitOnEnter = true;
			this._chainEnterFuncs();
			return React.createElement(
				"div",
				{ ref: this._selfFocusRef, onClick: event => event.stopPropagation() },
				this.props.children
			);
		}

		componentDidMount() {
			this._focusFirstField();
			window.addEventListener("keydown", event => this._submitOnEnter(event));

			// NOTE: these two prevents scrolling underneath popup (but not inside)
			this._selfFocusRef.current.parentNode.addEventListener("touchmove", event => {
				if (event.target !== this._selfFocusRef.current) {
					event.preventDefault();
				}
			});
			this._selfFocusRef.current.addEventListener("touchmove", event => event.stopPropagation());
		}

		_chainEnterFuncs() {
			this._focusRefs = [];
			let lastField = null;
			let nextFocusIdx = 0;
			for (let idx = 0; idx < this.props.children.length; idx++) {
				const child = this.props.children[idx];
				if (child.type === PopupInputField || child.type === PopupTextField) {
					if (lastField !== null) {
						const focusIdx = nextFocusIdx; // so idx doesnt mutate
						const selectNext = () => this._focusRefs[focusIdx].current.focus();
						lastField.props.onEnter = selectNext;
						lastField.props.onTab = selectNext;
					}

					let ref = child.ref;
					if (!ref) {
						ref = child.ref = React.createRef();
					}
					this._focusRefs.push(ref);

					lastField = child;
					nextFocusIdx++;
				}
			}
			if (lastField !== null) {
				lastField.props.onEnter = () => this._forceSubmit();
				lastField.props.onTab = () => this._focusRefs[0].current.focus();
				this._shouldSubmitOnEnter = false; // enter is being overridden!
			}
		}

		// NOTE: will only work if props are given a button to use as the "submit" button
		_submitOnEnter(event) {
			if (this._shouldSubmitOnEnter && event.key === "Enter") {
				this._forceSubmit();
			}
		}

		_forceSubmit() {
			this.props.submitButtonRef.current.click();
		}

		_focusFirstField() {
			if (this._focusRefs.length > 0) {
				this._focusRefs[0].current.focus();
			} else {
				this._focusSelf();
			}
		}
		_focusSelf() {
			// running .focus() on the div doesnt pull away from other textareas... but this does!
			const elem = this._selfFocusRef.current;
			const tempInp = document.createElement("input");
			elem.appendChild(tempInp);
			tempInp.focus();
			elem.removeChild(tempInp);
		}
	}

	class PopupSpacer extends ReactStyles.Component {
		makeStyle(when) {
			return {
				flex: 1
			};
		}

		render() {
			return React.createElement("div", null);
		}
	}

	class PopupTitle extends ReactStyles.Component {
		makeStyle(when) {
			return {
				"*": {
					color: "rgb(200, 200, 200)", // STYLE_PRESETS.color("softWhite")
					fontSize: "15pt",
					margin: "5px",
					textAlign: "center"
				}
			};
		}

		render() {
			if (typeof this.props.children === "string") {
				this.props.children = PopupTitle._splitNewlinesForString(this.props.children);
			} else if (this.props.children instanceof Array) {
				this.props.children = PopupTitle._splitNewlinesForArray(this.props.children);
			}

			return React.createElement(
				"div",
				null,
				this.props.children
			);
		}

		static _splitNewlinesForString(str) {
			return str.split('\\n').map(item => React.createElement(
				"h2",
				null,
				item || "\\0"
			));
		}

		static _splitNewlinesForArray(arr) {
			return arr.map(item => {
				if (typeof item === "string") {
					return PopupSubtitle._splitNewlinesForString(item);
				} else if (item instanceof Array) {
					return PopupSubtitle._splitNewlinesForArray(item);
				} else {
					return item;
				}
			});
		}
	}

	class PopupSubtitle extends ReactStyles.Component {
		makeStyle(when) {
			return {
				"*": {
					color: "rgb(200, 200, 200)", // STYLE_PRESETS.color("softWhite")
					fontSize: "11pt",
					margin: "5px",
					textAlign: "center"
				}
			};
		}

		render() {
			if (typeof this.props.children === "string") {
				this.props.children = PopupSubtitle._splitNewlinesForString(this.props.children);
			} else if (this.props.children instanceof Array) {
				this.props.children = PopupSubtitle._splitNewlinesForArray(this.props.children);
			}

			return React.createElement(
				"div",
				null,
				this.props.children
			);
		}

		static _splitNewlinesForString(str) {
			return str.split('\\n').map(item => React.createElement(
				"p",
				null,
				item || '\\0'
			));
		}

		static _splitNewlinesForArray(arr) {
			return arr.map(item => {
				if (typeof item === "string") {
					return PopupSubtitle._splitNewlinesForString(item);
				} else if (item instanceof Array) {
					return PopupSubtitle._splitNewlinesForArray(item);
				} else {
					return item;
				}
			});
		}
	}

	class PopupInputField extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this._ref = React.createRef();

			const check = this.addCheckForProp;
			check("onKeyDown", "possible-typeof", "function");
			check("onEnter", "possible-typeof", "function");
			check("onTab", "possible-typeof", "function");
		}

		get value() {
			return this._ref.current.value;
		}

		focus() {
			this._ref.current.focus();
		}

		makeStyle(when) {
			return {
				width: "100%",
				backgroundColor: "rgb(200, 200, 200)", // STYLE_PRESETS.color("softWhite")
				color: "rgb(37, 37, 48)", // STYLE_PRESETS.color("deepNavy")

				border: "none",
				borderRadius: "15px",
				padding: "5px",
				fontSize: "11pt",
				fontFamily: "sans-serif"
			};
		}

		render() {
			return React.createElement("input", { ref: this._ref, defaultValue: this.props.children, onKeyDown: event => {
					if (this.props.onKeyDown) {
						this.props.onKeyDown(event);
					}
					if (event.key === "Enter") {
						event.preventDefault();
						this.props.onEnter();
					} else if (event.key === "Tab") {
						event.preventDefault();
						this.props.onTab();
					}
				} });
		}
	}

	class PopupTextField extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this._ref = React.createRef();

			const check = this.addCheckForProp;
			check("onKeyDown", "possible-typeof", "function");
			check("rows", "possible-typeof", "number");
			check("onTab", "possible-typeof", "function");
		}

		get value() {
			return this._ref.current.value;
		}

		focus() {
			this._ref.current.focus();
		}

		makeStyle(when) {
			return {
				width: "100%",
				backgroundColor: "rgb(200, 200, 200)", // STYLE_PRESETS.color("softWhite")
				color: "rgb(37, 37, 48)", // STYLE_PRESETS.color("deepNavy")

				border: "none",
				borderRadius: "15px",
				padding: "5px",
				fontSize: "11pt",
				fontFamily: "sans-serif"
			};
		}

		render() {
			return React.createElement(
				"textarea",
				{ ref: this._ref, rows: this.props.rows || 3, onKeyDown: event => {
						if (this.props.onKeyDown) {
							this.props.onKeyDown(event);
						}
						if (event.key === "Tab") {
							event.preventDefault();
							this.props.onTab();
						}
					} },
				this.props.children
			);
		}
	}

	class PopupButton extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this._clickRef = React.createRef();

			const check = this.addCheckForProp;
			check("onClick", "possible-typeof", "function");
		}

		makeStyle(when) {
			return {
				margin: "0px",
				padding: "5px",
				minWidth: "40%",
				border: "none",
				borderRadius: "15px",

				fontSize: "13pt",

				color: "rgb(200, 200, 200)", // STYLE_PRESETS.color("softWhite")
				backgroundColor: "rgb(105, 105, 117)", // STYLE_PRESETS.color("ghostNavy")

				[when(":active")]: {
					backgroundColor: "rgb(57, 57, 69)" // STYLE_PRESETS.color("softNavy")
				}
			};
		}

		click() {
			this._clickRef.current.click();
		}

		render() {
			return React.createElement(
				"button",
				{ ref: this._clickRef, onClick: this.props.onClick },
				this.props.children
			);
		}
	}

	class PopupButtonList extends ReactStyles.Component {
		makeStyle(when) {
			return {
				width: "100%",

				display: "flex",
				flexFlow: "row nowrap"
			};
		}

		render() {
			return React.createElement(
				"div",
				{ style: { justifyContent: this._hasOneChild() ? "center" : "space-between" } },
				this.props.children
			);
		}

		_hasOneChild() {
			// Arrays are *only* used when there are multiple children
			return !(this.props.children instanceof Array);
		}
	}

	if (false) {
		class Container extends ReactStyles.Component {
			constructor(props) {
				super(props);

				this.state = { close: false };
			}

			makeStyle(when) {
				return React.createElement(
					"style",
					null,
					\`
				.Container {
					position: relative;
					padding: 0px;
					top: 10px;
					left: 10px;
				}
				.Container > h1 {
					position: relative;
					top: -20px;
					left: -20px;
					color: \${PRESET("ghostNavy")};
					background-color: \${PRESET("deepNavy")};
					margin: 0px;
				}
				
				.Container .PopupScreen {
					width: 300px;
					height: 180px;
				}
			\`
				);
			}

			render() {
				return React.createElement(
					"div",
					null,
					React.createElement(
						"h1",
						null,
						"TEST TEXT"
					),
					React.createElement(
						"h1",
						null,
						"TEST TEXT"
					),
					"popup",
					React.createElement("textarea", { wrap: "off" })
				);
			}

			componentDidMount() {
				setTimeout(() => {
					let pms = [POPUP.alert({ title: "TITLE\\n\\nTEST", subtitle: "newline\\ntrst" }), POPUP.prompt({ title: "Can you see me?", subtitle: "hopefully..." }, [], ["input", "text", "input"])];
					for (let i = 0; i < 4; i++) {
						pms.push(POPUP.confirm("test" + i));
					}

					const callback = async () => {
						for (const pm of pms) {
							alert((await pm));
						}
					};
					callback();
				}, 1500);
			}
		}
		ReactDOM.render(React.createElement(Container, null), root);
	}

	/* Themed for: Gospel Notes */

	/* PRESETS */
	const PRESET = (name, options) => ReactStyles.getPreset(name, options);
	ReactStyles.registerPreset("clear", "rgba(0, 0, 0, 0)");

	ReactStyles.registerPreset("deepNavy", { value: "37, 37, 48", type: "color" });
	ReactStyles.registerPreset("softNavy", { value: "57, 57, 69", type: "color" });
	ReactStyles.registerPreset("ghostNavy", { value: "105, 105, 117", type: "color" });
	ReactStyles.registerPreset("oceanBlue", { value: "39, 53, 155", type: "color" });

	ReactStyles.registerPreset("brightRed", { value: "245, 50, 50", type: "color" });
	ReactStyles.registerPreset("softRed", { value: "155, 15, 15", type: "color" });
	ReactStyles.registerPreset("darkRed", { value: "110, 0, 0", type: "color" });
	ReactStyles.registerPreset("deepRed", { value: "80, 0, 0", type: "color" });

	ReactStyles.registerPreset("softYellow", { value: "230, 190, 0", type: "color" });
	ReactStyles.registerPreset("dullYellow", { value: "140, 120, 0", type: "color" });
	ReactStyles.registerPreset("deepYellow", { value: "85, 75, 0", type: "color" });

	ReactStyles.registerPreset("hackerGreen", { value: "30, 240, 30", type: "color" });
	ReactStyles.registerPreset("strongGreen", { value: "20, 200, 20", type: "color" });
	ReactStyles.registerPreset("softGreen", { value: "10, 150, 10", type: "color" });
	ReactStyles.registerPreset("dullGreen", { value: "0, 100, 0", type: "color" });
	ReactStyles.registerPreset("deepGreen", { value: "0, 60, 0", type: "color" });
	ReactStyles.registerPreset("darkGreen", { value: "0, 40, 0", type: "color" });

	ReactStyles.registerPreset("hackerBlue", { value: "35, 105, 250", type: "color" });
	ReactStyles.registerPreset("strongBlue", { value: "20, 40, 215", type: "color" });
	ReactStyles.registerPreset("softBlue", { value: "15, 35, 185", type: "color" });
	ReactStyles.registerPreset("dullBlue", { value: "14, 32, 160", type: "color" });
	ReactStyles.registerPreset("deepBlue", { value: "11, 29, 130", type: "color" });
	ReactStyles.registerPreset("darkBlue", { value: "10, 18, 78", type: "color" });

	ReactStyles.registerPreset("brightWhite", { value: "255, 255, 255", type: "color" });
	ReactStyles.registerPreset("softWhite", { value: "200, 200, 200", type: "color" });

	ReactStyles.registerPreset("lightGrey", { value: "160, 160, 160", type: "color" });
	ReactStyles.registerPreset("softGrey", { value: "110, 110, 110", type: "color" });
	ReactStyles.registerPreset("darkGrey", { value: "60, 60, 60", type: "color" });

	ReactStyles.registerPreset("softBlack", { value: "20, 20, 20", type: "color" });
	ReactStyles.registerPreset("darkWarmBlack", { value: "20, 10, 2", type: "color" });
	ReactStyles.registerPreset("darkBlack", { value: "0, 0, 0", type: "color" });

	ReactStyles.registerPreset("activeBlue", { value: "28, 94, 233", type: "color" });
	ReactStyles.registerPreset("activeSoftBlue", { value: "18, 62, 158", type: "color" });
	ReactStyles.registerPreset("activeNightBlue", { value: "84, 92, 142", type: "color" });
	ReactStyles.registerPreset("activeShadow", { value: "2, 0, 12", type: "color" });

	/* THEMES */

	class MainAppDataRegistry {
		constructor() {
			this._registry = new StorageRegistry("MainApp-NoteDataRegistry");
		}
		ensureVersion() {
			const version = this._registry.getStoredStr("version") || '0.0.0';
			const [major, minor, patch] = version.split('.');
			if (major < 0 || minor < 2) {
				return false;
			}

			this.setVersion();
			return true;
		}
		setVersion() {
			this._registry.setStoredStr("version", VERSION.number);
		}

		hardReset() {
			this._registry.reset("hard");
			this.setVersion();
		}

		saveNotes(rootElements) {
			const dataList = rootElements.map(elem => PageElementLoader.toString(elem));
			const saveStr = JSON.stringify(dataList);
			this._registry.setStoredStr("allNoteData", saveStr);
		}

		loadNotes() {
			const saveStr = this._registry.getStoredStr("allNoteData");
			if (!saveStr) {
				return null;
			}

			const dataList = JSON.parse(saveStr);
			const elemList = dataList.map(elem => {
				if (elem) {
					elem = PageElementLoader.fromString(elem);
				}
				return elem;
			});
			return elemList;
		}

		saveSearchIndex(json) {
			this._registry.setStoredStr("searchIndex", json);
		}

		loadSearchIndex() {
			return this._registry.getStoredStr("searchIndex");
		}
	}

	class MainAppNoteDragHandler {
		constructor() {
			this._selBoxHandler = new this.constructor.SelectionBoxHandler();
		}

		beforeDrag(elem, initX, initY) {
			this._selBoxHandler.delete(); // in case afterDrag is not called (bug...?)

			this._dragElem = elem;
			this._recordInitVals(initX, initY);
			this._addShadow();

			const elemIdx = this._getElementIndex(elem);
			this._origElemIdx = elemIdx;
			this._selBoxHandler.create(elemIdx, this._dragElem, this._scrollParent);
			this._selBoxHandler.hideBox();
		}

		onDrag(touchX, touchY, addOffset) {
			this._shouldManualScroll(touchX, touchY, addOffset);
			if (!this._manualScrollStarted) {
				this._manualScroll();
				this._selBoxHandler.showBox();
				this._manualScrollStarted = true;
			}
		}

		afterDrag(onDrop) {
			clearInterval(this._afterDragInterval);
			this._afterDragInterval = null;

			this._stopManualScroll();
			this._selBoxHandler.delete();
			this._removeShadow();

			onDrop(this._origElemIdx, this._selBoxHandler.boxIdx);
		}

		_getElementIndex(elem) {
			let idx = 0;
			while (elem = elem.previousSibling) {
				idx++;
			}
			return idx;
		}

		_recordInitVals(initX, initY) {
			let container = this._dragElem;
			while (!(container.classList.contains("Container") && container.parentNode.classList.contains("DropdownContent"))) {
				container = container.parentNode;
			}
			this._scrollParent = container;

			this._initVals = {
				scrollRect: this._scrollParent.getBoundingClientRect(),
				scrollHeight: this._scrollParent.scrollHeight,
				touchX: initX,
				touchY: initY
			};

			this._manualScrollStarted = false;
		}

		_shouldManualScroll(x, y, addOffset) {
			const scaledElem = this._dragElem.children[0];
			const viewDragRect = scaledElem.getBoundingClientRect();
			// relative to the viewport
			const viewDragMid = viewDragRect.top + viewDragRect.height / 2;

			// transforms from view-relative to scroll-window-relative coordinates
			const scrollRect = this._initVals.scrollRect;
			this._lastScrollDragMid = viewDragMid - scrollRect.top + this._scrollParent.scrollTop;

			// proximity to scroll parent top/bottom
			const topDiff = viewDragMid - scrollRect.top;
			const bottomDiff = scrollRect.bottom - viewDragMid;

			const boundSize = 100;
			const maxScroll = 20;
			// scroll up
			if (topDiff < boundSize) {
				const scrollBy = -maxScroll * (boundSize - topDiff) / boundSize;
				if (scrollBy < -maxScroll) {
					this._scrollBy = -maxScroll;
				} else {
					this._scrollBy = Math.trunc(scrollBy);
				}
				this._callOnScroll = addOffset;
			}
			// scroll down
			else if (bottomDiff < boundSize) {
					const scrollBy = maxScroll * (boundSize - bottomDiff) / boundSize;
					if (scrollBy > maxScroll) {
						this._scrollBy = maxScroll;
					} else {
						this._scrollBy = Math.trunc(scrollBy);
					}
					this._callOnScroll = addOffset;
				}
				// in middle; no scroll
				else {
						this._scrollBy = 0;
					}
		}

		_manualScroll() {
			// allows cancelling the chain by setting scrollBy = null
			if (typeof this._scrollBy === "number") {
				if (this._scrollBy !== 0) {
					const scrollTop = this._scrollParent.scrollTop;
					const scrollBottom = scrollTop + this._scrollParent.clientHeight;
					// clamps scrolling to original scroll height (since it expands if the note animates outside bottom bounds)
					if (scrollBottom + this._scrollBy > this._initVals.scrollHeight) {
						const remainScrollFromBottom = this._initVals.scrollHeight - scrollBottom;
						this._scrollParent.scrollBy(0, remainScrollFromBottom);
					} else {
						this._scrollParent.scrollBy(0, this._scrollBy);
					}

					const transDiff = this._scrollParent.scrollTop - scrollTop;
					// stops moving note when stopped scrolling
					if (transDiff !== 0) {
						this._callOnScroll(0, transDiff);
						this._lastScrollDragMid += transDiff; // in case touch doesnt move/update and we are scrolling
					}
				}
				this._selBoxHandler.afterScroll(this._lastScrollDragMid);

				window.requestAnimationFrame(() => this._manualScroll());
			}
		}

		_stopManualScroll() {
			this._scrollBy = null;
		}

		_addShadow() {
			const elem = this._dragElem.children[0]; // scale container
			const wrapper = this._shadowElem = document.createElement("div");
			const shadow = document.createElement("div");
			elem.appendChild(wrapper);
			wrapper.appendChild(shadow);

			wrapper.style.position = "relative";
			wrapper.style.top = \`-\${this._dragElem.offsetHeight}px\`;
			// NOTE: these ensure the shadow doesnt interfere with size
			wrapper.style.width = "0px";
			wrapper.style.height = "0px";

			shadow.style.width = this._dragElem.offsetWidth + "px";
			shadow.style.height = this._dragElem.offsetHeight + "px";
			shadow.style["background-color"] = "rgba(10, 10, 30, 0.18)";
		}

		_removeShadow() {
			this._shadowElem.parentNode.removeChild(this._shadowElem);
		}

		// calculations are made relative to the scroll window
		static get SelectionBoxHandler() {
			if (!this._SelectionBoxHandler) {
				this._SelectionBoxHandler = class {
					create(initBoxIdx, dragElem, scrollParent) {
						this.boxIdx = initBoxIdx;
						const dRect = dragElem.getBoundingClientRect();
						const sRect = scrollParent.getBoundingClientRect();

						const selBox = this._selectionBox = document.createElement("div");
						// NOTE: a wrapper is used so the selection box does not overflow outside the content area
						// while still using the "absolute" positioning scheme
						const absPositionWrapper = document.createElement("div");
						absPositionWrapper.appendChild(selBox);
						scrollParent.appendChild(absPositionWrapper);

						selBox.style["background-color"] = PRESET("activeBlue", { alpha: 0.2 });
						selBox.style.width = dRect.width + "px";
						selBox.style.height = dRect.height + "px";

						selBox.style.margin = "0px";
						selBox.style.padding = "0px";
						selBox.style.position = "absolute";
						selBox.style.left = dRect.left - sRect.left + "px";

						absPositionWrapper.style.margin = "0px";
						absPositionWrapper.style.padding = "0px";
						absPositionWrapper.style.position = "relative";
						absPositionWrapper.style.left = -absPositionWrapper.offsetLeft + "px";
						absPositionWrapper.style.top = -absPositionWrapper.offsetTop + "px";

						this._recordBoundingRects(scrollParent);
						this._updateBoxPosition();
					}

					delete() {
						if (this._selectionBox) {
							const wrapper = this._selectionBox.parentNode;
							wrapper.parentNode.removeChild(wrapper);
							this._selectionBox = null;
							this._boundingRects = null;
						}
					}

					hideBox() {
						this._selectionBox.style.display = "none";
					}

					showBox() {
						this._selectionBox.style.display = "block";
					}

					afterScroll(dragMid) {
						// check in order of most likely to least likely
						const rectsMap = [0, 1, -1, 2, -2];
						const boundingRects = rectsMap.map(num => this._boundingRects[this.boxIdx + num]);

						for (let i = 0; i < boundingRects.length; i++) {
							const currRect = boundingRects[i];
							if (!currRect) {
								continue;
							}

							// simply checks if the overlap point is within a rects bounds
							if (dragMid > currRect.top && dragMid < currRect.bottom) {
								// updates the selected element index
								this.boxIdx += rectsMap[i];
								this._updateBoxPosition();
								break; // found the right rect!
							}
						}
					}

					_recordBoundingRects(dragElemParent) {
						this._boundingRects = [];

						let sibling = dragElemParent.children[0];
						while (sibling !== null) {
							// ensures the add button is not included
							if (sibling.classList.contains("Draggable")) {
								const top = sibling.offsetTop;
								const height = sibling.offsetHeight;
								// NOTE: only top and bottom are needed; this is an optimization for less rects!
								this._boundingRects.push({ top, height, bottom: top + height });
							}
							sibling = sibling.nextSibling;
						}
					}

					_updateBoxPosition() {
						const rect = this._boundingRects[this.boxIdx];

						const elem = this._selectionBox;
						elem.style.top = rect.top + "px";
						elem.style.height = rect.height + "px";
					}
				};
			}
			return this._SelectionBoxHandler;
		}
	}

	class MainAppNoteDragHandlerNASTY {
		beforeDrag(elem, initX, initY) {
			this._deleteSelectionBox(); // in case afterDrag is not called (bug...?)

			this._dragElem = elem;
			this._addShadow();
			this._prepareManualScroll(initX, initY);

			const elemIdx = this._getElementIndex(elem);
			this._selectedElemIdx = elemIdx;
			this._origElemIdx = elemIdx;
			this._createSelectionBox();
			this._prepareSelectionBoxBounds();
		}

		onDrag(touchX, touchY, addOffset) {
			this._shouldManualScroll(touchX, touchY, addOffset);
		}

		afterDrag(onDrop) {
			this._stopManualScroll();
			this._deleteSelectionBox();
			this._removeShadow();

			if (this._selectedElemIdx !== this._origElemIdx) {
				onDrop(this._selectedElemIdx);
			}
		}

		_getElementIndex(elem) {
			let idx = 0;
			while (elem = elem.previousSibling) {
				idx++;
			}
			return idx;
		}

		_prepareManualScroll(initX, initY) {
			let container = this._dragElem;
			while (!(container.classList.contains("Container") && container.parentNode.classList.contains("DropdownContent"))) {
				container = container.parentNode;
			}
			this._scrollParent = container;
			this._scrollParentRect = container.getBoundingClientRect();
			this._scrollParentInitHeight = container.scrollHeight;

			this._dragElemRect = this._dragElem.getBoundingClientRect();
			this._dragElemOrigOffsetTop = this._dragElem.offsetTop;
			this._dragElemOrigOffsetBottom = this._dragElem.offsetTop + this._dragElem.offsetHeight;

			this._initTouchX = initX;
			this._initTouchY = initY;
			this._manualScrollStarted = false;
		}

		_shouldManualScroll(x, y, addOffset) {
			const origDragRect = this._dragElemRect; // original rect values
			const scrollRect = this._scrollParentRect;

			// (absolute) pseudo-rect values for the animated/scaled element
			const dragDiffY = y - this._initTouchY;
			const dragRectTop = origDragRect.top + dragDiffY;
			const dragRectHeight = Math.min(origDragRect.height, 200);
			// const dragRectMid = dragRectTop + dragRectHeight / 2

			const currRect = this._dragElem.children[0].getBoundingClientRect();
			const dragRectMid = currRect.top + currRect.height / 2;
			this._lastUpdatedDragMid = dragRectMid - scrollRect.top + this._scrollParent.scrollTop;

			const topDiff = dragRectMid - scrollRect.top;
			const bottomDiff = scrollRect.bottom - dragRectMid;

			const boundSize = 80;
			const maxScroll = 25;
			// scroll up
			if (topDiff < boundSize) {
				const scrollBy = -maxScroll * (boundSize - topDiff) / boundSize;
				if (scrollBy < -maxScroll) {
					this._scrollBy = -maxScroll;
				} else {
					this._scrollBy = Math.trunc(scrollBy);
				}
				this._offsetOnScroll = addOffset;
			}
			// scroll down
			else if (bottomDiff < boundSize) {
					const scrollBy = maxScroll * (boundSize - bottomDiff) / boundSize;
					if (scrollBy > maxScroll) {
						this._scrollBy = maxScroll;
					} else {
						this._scrollBy = Math.trunc(scrollBy);
					}
					this._offsetOnScroll = addOffset;
				}
				// in middle; no scroll
				else {
						this._scrollBy = 0;
					}

			if (!this._manualScrollStarted) {
				this._manualScroll();
				this._selectionBox.style.display = "inline-block";
				this._manualScrollStarted = true;
			}
		}

		_manualScroll() {
			// allows cancelling the chain by setting scrollBy = null
			if (typeof this._scrollBy === "number") {
				if (this._scrollBy !== 0) {
					const scrollTop = this._scrollParent.scrollTop;
					const scrollBottom = scrollTop + this._scrollParent.clientHeight;
					// clamps scrolling to original scroll height (since it expands if the note animates outside bottom bounds)
					if (scrollBottom + this._scrollBy > this._scrollParentInitHeight) {
						const clampScroll = this._scrollParentInitHeight - scrollBottom;
						this._scrollParent.scrollBy(0, clampScroll);
					} else {
						this._scrollParent.scrollBy(0, this._scrollBy);
					}

					const transDiff = this._scrollParent.scrollTop - scrollTop;
					// stops moving note when stopped scrolling
					if (transDiff !== 0) {
						this._offsetOnScroll(0, transDiff);
					}
				}
				window.requestAnimationFrame(() => this._manualScroll());

				// throttled check every frame
				this._checkUpdateSelectionBox();
				this._updateSelectionBoxPosition();
			}
		}

		_stopManualScroll() {
			this._scrollBy = null;
		}

		_prepareSelectionBoxBounds() {
			this._possibleRectsElems = [];

			let sibling = this._dragElem.parentNode.children[0];
			while (sibling !== null) {
				// ensures the add button is not included
				if (sibling.classList.contains("NoteBox")) {
					const top = sibling.offsetTop;
					const height = sibling.offsetHeight;
					this._possibleRectsElems.push({ top, height, bottom: top + height });
				}
				sibling = sibling.nextSibling;
			}
		}

		_createSelectionBox() {
			const dRect = this._dragElemRect;
			const sRect = this._scrollParentRect;

			const elem = this._selectionBox = document.createElement("div");
			elem.style.display = "none";
			// NOTE: a wrapper is used so the selection box does not overflow outside the content area
			// while still using the "absolute" positioning scheme
			const elemPositionWrapper = document.createElement("div");
			elemPositionWrapper.appendChild(elem);
			this._scrollParent.appendChild(elemPositionWrapper);

			elem.style["background-color"] = PRESET("activeBlue", { alpha: 0.2 });
			elem.style.width = dRect.width + "px";
			elem.style.height = dRect.height + "px";

			elem.style.margin = "0px"; // removes regular note margins set by container
			elem.style.position = "absolute";
			elem.style.left = dRect.left - this._scrollParentRect.left + "px";
			this._setSelectionBoxPosition(dRect.top, dRect.height);

			elemPositionWrapper.style.margin = "0px";
			elemPositionWrapper.style.position = "relative";
			elemPositionWrapper.style.left = -elemPositionWrapper.offsetLeft + "px";
			elemPositionWrapper.style.top = -elemPositionWrapper.offsetTop + "px";
		}

		_checkUpdateSelectionBox() {
			const newDragOverlap = this._lastUpdatedDragMid;
			// check in order of most likely to least likely
			const rectsMap = [0, 1, -1, 2, -2];
			const boundingRects = rectsMap.map(num => {
				const rect = this._possibleRectsElems[this._selectedElemIdx + num];
				return rect;
			});

			for (let i = 0; i < boundingRects.length; i++) {
				const currRect = boundingRects[i];
				if (!currRect) {
					continue;
				}

				// simply checks if the overlap point is within a rects bounds
				if (newDragOverlap > currRect.top && newDragOverlap < currRect.bottom) {
					// updates the selected element index
					this._selectedElemIdx += rectsMap[i];

					this._setSelectionBoxPosition(currRect.top, currRect.height);
					this._updateSelectionBoxPosition();
					break; // found the right rect!
				}
			}
		}

		_setSelectionBoxPosition(newTop, newHeight) {
			this._selectionBoxTop = newTop;
			this._selectionBoxHeight = newHeight;
		}

		_updateSelectionBoxPosition() {
			if (this._lastSelectionBoxTop !== this._selectionBoxTop) {
				const elem = this._selectionBox;
				const offRect = this._scrollParentRect;
				elem.style.top = this._selectionBoxTop + this._scrollParentRect.top - offRect.top + "px";
				elem.style.height = this._selectionBoxHeight + "px";

				this._lastSelectionBoxTop = this._selectionBoxTop;
			}
		}

		_deleteSelectionBox() {
			if (this._selectionBox) {
				this._selectionBox.parentNode.parentNode.removeChild(this._selectionBox.parentNode);
			}
			this._selectionBox = null;
			this._possibleRects = null;
		}

		_addShadow() {
			const elem = this._dragElem.children[0]; // scale container
			const wrapper = this._shadowElem = document.createElement("div");
			wrapper.style.position = "relative";
			wrapper.style.top = \`-\${this._dragElem.offsetHeight}px\`;
			// NOTE: these ensure the shadow doesnt interfere with size
			wrapper.style.width = "0px";
			wrapper.style.height = "0px";
			elem.appendChild(wrapper);

			const shadow = document.createElement("div");
			shadow.style.width = this._dragElem.offsetWidth + "px";
			shadow.style.height = this._dragElem.offsetHeight + "px";
			shadow.style["background-color"] = "rgba(10, 10, 30, 0.18)";
			wrapper.appendChild(shadow);
		}

		_removeShadow() {
			this._dragElem.children[0].removeChild(this._shadowElem);
		}
	}

	class LunrWorker {
		constructor(refName, ...fields) {
			if (!refName || typeof refName !== "string") {
				throw new Error("LunrWorker objects must be created with a string");
			}

			this._idx = lunr(idx => {
				idx.ref(refName);
				for (let i = 0; i < fields.length; i++) {
					const field = fields[i];
					idx.field(field);
				}
			});
			this._refName = refName;
			this._origRefKey = Symbol();
			this._docs = {};
		}

		doc(refOrDoc) {
			if (typeof refOrDoc === "string") {
				refOrDoc = this._docs[refOrDoc];
			}
			return refOrDoc;
		}

		add(doc) {
			this._recordNewDoc(doc);
			this._idx.add(doc);
		}
		_recordNewDoc(doc) {
			const ref = doc[this._refName];
			if (this._docs[ref]) {
				throw new Error(\`LunrWorker cannot re-add document '\${ref}'\`);
			}

			this._docs[ref] = doc;

			if (doc[this._origRefKey] === undefined) {
				this._wrapRefProp(doc);
			}
		}

		remove(ref) {
			const doc = this.doc(ref);
			if (!doc) {
				throw new Error(\`LunrWorker.remove() failed: '\${ref} is an invalid reference'\`);
			}
			ref = doc[this._refName];

			delete this._docs[ref];
			this._idx.remove(doc);
		}

		update(ref, newRef = null) {
			const doc = this.doc(ref);
			if (!doc) {
				throw new Error(\`LunrWorker.update() failed: '\${ref} is an invalid reference'\`);
			}
			ref = doc[this._refName];

			if (typeof newRef === "string") {
				delete this._docs[ref];
				this._idx.remove(doc);

				doc[this._refName] = { value: newRef, _inUpdate: true };
				this._docs[newRef] = doc;
				this._idx.add(doc);
			} else if (newRef) {
				const newDoc = newRef;
				newRef = newDoc[this._refName];

				delete this._docs[ref];
				this._idx.remove(doc);

				this._docs[newRef] = newDoc;
				this._idx.add(newDoc);
			} else {
				this._idx.update(doc);
			}
		}

		copyDocsTo(listRef = {}, filter = null) {
			// return array
			if (Array.isArray(listRef)) {
				for (const ref in this._docs) {
					const doc = this._docs[ref];
					if (typeof filter === "function") {
						if (filter(doc)) {
							listRef.push(doc);
						}
					} else {
						listRef.push(doc);
					}
				}
			}

			// return object dictionary
			else {
					for (const ref in this._docs) {
						const doc = this._docs[ref];
						if (typeof filter === "function") {
							if (filter(doc)) {
								listRef[ref] = doc;
							}
						} else {
							listRef[ref] = doc;
						}
					}
				}

			return listRef;
		}

		search(query) {
			const result = this._idx.search(query);
			const resultMapped = result.map(({ ref, score }) => {
				return { refName: ref, ref: this.doc(ref), score };
			});
			return resultMapped;
		}

		asJSON() {
			return JSON.stringify(this._idx);
		}

		loadFrom(str, docList) {
			this._idx = lunr.Index.load(JSON.parse(str));

			this._docs = {};
			if (Array.isArray(docList)) {
				for (let i = 0; i < docList.length; i++) {
					this._recordNewDoc(docList[i]);
				}
			} else {
				for (const docRef in docList) {
					this._recordNewDoc(docList[docRef]);
				}
			}
		}

		_wrapRefProp(doc) {
			const refKey = this._origRefKey;
			doc[refKey] = doc[this._refName];
			Object.defineProperty(doc, this._refName, {
				get() {
					return doc[refKey];
				},
				set(val) {
					if (typeof val !== "object" || !val._inUpdate) {
						throw new Error("LunrWorker restircts manually updating document references (use the update() method instead)");
					}
					doc[refKey] = val.value;
				}
			});
		}
	}

	class MainAppSearchIndex {
		constructor() {
			this._notesIdx = new LunrWorker("id", "title", "content");
			this._groupsIdx = new LunrWorker("id", "name", "noteTitles", "noteContents");
		}

		addPageElem(pageElem) {
			const doc = pageElem.toDoc();
			switch (pageElem.type) {
				case "folder":
				case "notebook":
					{
						this._groupsIdx.add(doc);
					}
					break;

				case "note":
					{
						this._notesIdx.add(doc);
					}
					break;
			}

			this.pageElemUpdated(pageElem.parent);
		}

		removePageElem(pageElem) {
			let id = pageElem;
			if (typeof id !== "string") {
				id = id.id;
			}

			let doc;
			if (doc = this._groupsIdx.doc(id)) {
				this._groupsIdx.remove(doc);
			} else if (doc = this._notesIdx.doc(id)) {
				this._notesIdx.remove(doc);
			} else {
				throw new Error("Search index cannot remove undefined page element");
			}

			this.pageElemUpdated(pageElem.parent);
		}

		// called when the name of a container element changes
		pageElemRenamed(pageElem) {
			let id = pageElem;
			if (typeof id !== "string") {
				id = id.id;
			}

			let doc;
			if (doc = this._groupsIdx.doc(id)) {
				pageElem = doc.origElem;
				this._groupsIdx.update(id, pageElem.toDoc());
			} else {
				throw new Error("Search index cannot rename undefined page element container");
			}
		}

		// called when the content/children updates
		pageElemUpdated(pageElem) {
			if (!pageElem) {
				return;
			}

			let id = pageElem;
			if (typeof id !== "string") {
				id = id.id;
			}

			let doc;
			if (doc = this._groupsIdx.doc(id)) {
				pageElem = doc.origElem;
				this._groupsIdx.update(id, pageElem.toDoc());
			} else if (doc = this._notesIdx.doc(id)) {
				pageElem = doc.origElem;
				this._notesIdx.update(id, pageElem.toDoc());
			} else {
				throw new Error("Search index cannot update undefined page element");
			}

			this.pageElemUpdated(pageElem.parent);
		}

		search(inPageElems, query) {
			if (!Array.isArray(inPageElems)) {
				throw new Error("Search Index error: First argument in search() must be an array of page elements");
			}
			if (typeof query !== "string") {
				throw new Error("Search Index error: Second argument in search() must be a string");
			}

			const isValidChild = result => {
				const pageElem = result.ref.origElem;
				if (!pageElem.parent) {
					return false;
				}

				return inPageElems.includes(pageElem.parent);
			};
			const toElem = result => {
				const { ref, score } = result;
				return { pageElem: ref.origElem, score };
			};

			let groupResults = this._groupsIdx.search(query);
			let noteResults = this._notesIdx.search(query);

			groupResults = groupResults.filter(isValidChild);
			noteResults = noteResults.filter(isValidChild);

			groupResults = groupResults.map(toElem);
			noteResults = noteResults.map(toElem);

			return { groupResults, noteResults };
		}

		// functions that help with loading/saving the index
		getSerializedStr() {
			return JSON.stringify([this._notesIdx.asJSON(), this._groupsIdx.asJSON()]);
		}

		loadFromSerialized(jsonStr, rootPageData) {
			let notesDocList = [];
			let groupsDocList = [];
			const { questions, lessons, discussions } = rootPageData;
			this._parseDocLists(questions, notesDocList, groupsDocList);
			this._parseDocLists(lessons, notesDocList, groupsDocList);
			this._parseDocLists(discussions, notesDocList, groupsDocList);

			const [notesStr, groupsStr] = JSON.parse(jsonStr);
			this._notesIdx.loadFrom(notesStr, notesDocList);
			this._groupsIdx.loadFrom(groupsStr, groupsDocList);
		}

		_parseDocLists(pageElem, notesList, groupsList) {
			const doc = pageElem.toDoc();
			switch (pageElem.type) {
				case "folder":
				case "notebook":
					{
						groupsList.push(doc);
						pageElem.forChildren(child => {
							this._parseDocLists(child, notesList, groupsList);
						});
					}
					break;

				case "note":
					{
						notesList.push(doc);
					}
					break;
			}
		}
	}

	class MainAppTopBar extends ReactStyles.PureComponent {
		constructor(props) {
			super(props);

			const check = this.addCheckForProp;
			check("menuContent", "possible-typeof", "object");
			check("menuContentChanged", "possible-typeof", "boolean");
			check("forceMenuHidden", "possible-typeof", "boolean");

			check("selectedIdx", "possible-typeof", "number");
			check("onButtonClick", "possible-typeof", "function");
			check("onSearchInactive", "possible-typeof", "function");
			check("onSearchActive", "possible-typeof", "function");
			check("onSearchClick", "possible-typeof", "function");
		}

		shouldComponentUpdate(nextProps, nextState) {
			return nextProps.forceMenuHidden !== this.props.forceMenuHidden || nextProps.selectedIdx !== this.props.selectedIdx || nextProps.menuContentChanged;
		}

		render() {
			return React.createElement(TopBar, {
				selectedIdx: this.props.selectedIdx,
				onButtonClick: idx => this.props.onButtonClick(idx),
				onSearchClick: query => this.props.onSearchClick(query),
				onSearchActive: () => this.props.onSearchActive(),
				onSearchInactive: () => this.props.onSearchInactive(),
				forceMenuHidden: this.props.forceMenuHidden,
				menuContent: this.props.menuContent
			});
		}
	}

	class MainPage extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this._lastContent = null;

			const check = this.addCheckForProp;
			check("children", "typeof", "function");
			check("canLoad", "typeof", "boolean");
		}

		makeStyle(when) {
			return {
				width: "100%",
				height: "100%",

				backgroundColor: PRESET("deepNavy")
			};
		}

		shouldComponentUpdate(nextProps, nextState) {
			return nextProps.canLoad;
		}

		render() {
			return React.createElement(
				"div",
				{ className: "MainPage" },
				this.props.children()
			);
		}
	}

	class MainPageDropdown extends ReactStyles.PureComponent {
		static get animateAsDropdownBar() {
			return true;
		}

		constructor(props) {
			super(props);

			this.state = {
				name: null,
				children: null
			};

			const check = this.addCheckForProp;
			const isPageElement = val => PageElementBase.isPageElement(val) ? '' : "value must be a page element";
			check("source", "custom", isPageElement);
			check("children", "typeof", "function");
			check("onRename", "possible-typeof", "function");

			// used by <DropdownAnimationGroup />
			check("_beforeDrop", "possible-typeof", "function");
		}

		static getDerivedStateFromProps(props, state) {
			const { name } = props.source;
			state.name = name;
			state.children = props.children(); // function (instead of array/etc) allows updating children across updates
		}

		shouldComponentUpdate(nextProps, nextState) {
			return nextProps.source !== this.props.source || nextState.name !== this.state.name;
		}

		render() {
			// <Reorderable key={id} ordering={this.state.reorganizeMode}>
			let { name, children } = this.state;
			return React.createElement(
				DropdownBar,
				{
					title: name,
					iconType: "blank",
					onMouseHold: () => this.props.onRename(),
					_beforeDrop: (elem, dropped) => this.props._beforeDrop(elem, dropped)
				},
				children
			);
		}
	}

	class MainPageNoteBox extends ReactStyles.PureComponent {
		constructor(props) {
			super(props);

			this.state = {
				title: null,
				content: null,
				disabled: false
			};

			this._dragRef = React.createRef();

			const check = this.addCheckForProp;
			const isPageElement = val => PageElementBase.isPageElement(val) ? '' : "value must be a page element";
			check("source", "custom", isPageElement);
			check("onTitleChange", "possible-typeof", "function");
			check("onContentChange", "possible-typeof", "function");

			check("dragRef", "possible-typeof", "object");
			check("beforeDrag", "possible-typeof", "function");
			check("onDrag", "possible-typeof", "function");
			check("afterDrag", "possible-typeof", "function");
		}

		static getDerivedStateFromProps(props, state) {
			const { title, content } = props.source;
			state.title = title;
			state.content = content;
		}

		shouldComponentUpdate(nextProps, nextState) {
			const shouldUpdate = nextProps.source !== this.props.source || nextState.title !== this.state.title || nextState.content !== this.state.content || nextState.disabled !== this.state.disabled;

			if (!shouldUpdate) {
				this.props.dragRef = nextProps.dragRef;
				this._updateDragRef();
			}
			return shouldUpdate;
		}

		render() {
			return React.createElement(
				Draggable,
				{
					dragRef: this._dragRef,
					beforeDrag: (initX, initY) => {
						this._prepareForDrag();
						this.props.beforeDrag(initX, initY);
					},
					onDrag: (x, y, addOffset) => {
						this._disableNote();
						this.props.onDrag(x, y, addOffset);
					},
					afterDrag: () => {
						this._enableNote();
						this.props.afterDrag();
					}
				},
				React.createElement(NoteBox, {
					title: this.state.title,
					content: this.state.content

					// NOTE: overwriting must be disabled during a drag to maintain note dimensions (for
					// selection and shadow box); note is "disabled" during drag, hence why it is also used here
					, preventOverwrite: this.state.disabled

					// NOTE: this prevents typing in case the element was dragged while
					// textarea was in focus, and also records in case the text changed
					// (to prevent loss of data)
					, forceBlur: this.state.disabled,
					forceDetectChange: this.state.disabled,

					onTitleChange: newTitle => this.props.onTitleChange(newTitle),
					onContentChange: newContent => this.props.onContentChange(newContent)
				})
			);
		}

		componentDidMount() {
			this._updateDragRef();
		}

		componentDidUpdate() {
			this._updateDragRef();
		}

		_updateDragRef() {
			if (typeof this.props.dragRef === "object") {
				this.props.dragRef.current = this._dragRef.current;
			} else if (typeof this.props.dragRef === "function") {
				this.props.dragRef(this._dragRef.current);
			}
		}

		_prepareForDrag() {
			this._shouldDisableOnDrag = false;
			this._didDisableOnDrag = false;
			this._disableTimeout = setTimeout(() => this._shouldDisableOnDrag = true, 250);
		}

		_disableNote() {
			if (this._shouldDisableOnDrag && !this._didDisableOnDrag) {
				this._didDisableOnDrag = true;
				this.setState({ disabled: true });
			}
		}

		_enableNote() {
			clearTimeout(this._disableTimeout);
			if (this._didDisableOnDrag) {
				this.setState({ disabled: false });
			}
		}
	}

	class MainPageSlideBar extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {};
		}
	}

	/* PageElements -- A custom type
 	This file contains a custom data structure for use in the Main
 	Application. These object types include (all invokable classes):
 		- PageFolder
 		- PageNotebook
 		- PageNote
 	Other contents of this file include:
 		- PageElement abstract/base classes (dont invoke directly!)
 		- PageElementLoader
 	
 	PageElements extend the base class, however they do not provide their
 	own constructors. Instead, they should provide make() and load()
 	functions that modify "this" to conform to the objects needs. These
 	functions act just like the constructor, and should call super.make()
 	and super.load() methods respectively. The only difference between the
 	two is make() is called to create a fresh new PageElement, much like
 	how any standard constructor() should work. However, load() is called
 	to build an object from pre-loaded variables (invoked inside the
 	PageElementLoader with needed arguments). For example, the PageFolder
 	make() method only requires the element name, but the load() method
 	requires the name, id, and raw array of children. As a safety feature,
 	PageElement load() methods are only allowed to be called by a
 	PageElementLoader, and will error if executed otherwise (including
 	inside a make(), and therefore should not be used to reuse code; use
 	an intermediate function like __PageElementBase_makeSelf(); note a
 	unique name is required since children could attempt to override it).
 	
 	The PageElementLoader contains several static methods intended to
 	enable saving/loading of PageElements by converting them to strings.
 	This does not use JSON, and instead uses a custom string structure.
 	This allows for only critical data to be stored and therefore takes
 	up less memory when saving to the device.
 */

	class PageElementBase {
		// used by PageElementLoader to signal creating an element manually
		static get _isLoading() {
			if (this.__loading === undefined) {
				this.__loading = false;
			}
			return this.__loading;
		}
		static set _isLoading(val) {
			this.__loading = val;
		}

		static isPageElement(elem) {
			return typeof elem === "object" && elem.__IS_PAGE_ELEMENT__;
		}

		// NOTE: an ID consists of the unix time an element was created and
		// a numberic counter counting up from zero on initialization; this
		// ensures elements created both over multiple program loads and
		// multiple times per millisecond will have unique IDs
		static createID() {
			const unixTime = new Date().getTime();
			if (!PageElementBase._idCounter) {
				PageElementBase._idCounter = 0;
			}
			const idNum = PageElementBase._idCounter++;
			return unixTime + '_' + idNum;
		}

		constructor(...args) {
			this.__PageElement_makeOrLoadRan = false;

			if (!this.constructor._isLoading) {
				this.make(...args);
				if (!this.__PageElement_makeOrLoadRan) {
					throw new Error("PageElement.make() did not call super.make()");
				}
			}
		}

		make(type, name) {
			if (this.__PageElement_makeOrLoadRan) {
				throw new Error("PageElement.make() can only be invoked by constructing a new PageElement()");
			}
			this.__PageElement_makeOrLoadRan = true;

			const validTypes = {
				folder: true,
				notebook: true,
				note: true
			};
			if (!validTypes[type]) {
				throw new Error(\`Invalid PageElement type: \${type}\`);
			}

			const id = this.constructor.createID();
			this.__PageElementBase_makeSelf(type, id, name);
		}
		__PageElementBase_makeSelf(type, id, name) {
			Object.defineProperties(this, {
				__IS_PAGE_ELEMENT__: { value: true, writable: false },
				id: { value: id, writable: false }
			});
			this.name = name;
			this.type = type;

			this._absPath = this.id; // used in search method of search index
			this._parentIdx = null;
			this._parent = null;

			this._shouldUpdate = false; // TODO: remove

			this.ref = React.createRef();
		}

		load(type, id, name) {
			if (!this.constructor._isLoading || this.__PageElement_makeOrLoadRan) {
				throw new Error("Cannot call PageElementBase.load() manually; use PageElementLoader instead");
			}
			this.__PageElement_makeOrLoadRan = true;

			this.__PageElementBase_makeSelf(type, id, name);
		}

		toString() {
			return \`[object \${this.constructor.name} \${this.id}]\`;
		}

		async triggerUpdate() {
			await this.ref.current.forceUpdate();
		}

		// TODO: remove this unneeded garbage
		shouldUpdate() {
			if (this._shouldUpdate) {
				this._shouldUpdate = false;
				return true;
			}
			return false;
		}

		get parent() {
			return this._parent;
		}

		set parent(pageElem) {
			if (pageElem !== this._parent) {
				if (pageElem) {
					pageElem.addChild(this);
				} else {
					if (this._parent) {
						this._parent.removeChild(this);
					}

					this._parent = null;
					this._parentIdx = null;
				}
			}
		}

		toDoc() {
			throw new Error("PageElementBase does not have a default document representation; this must be implemented by subclasses");
		}

		get absPath() {
			return this._absPath;
		}

		get absPathSep() {
			return ' ';
			// kept in case paths need to go back to using names...
			// return '»'
		}

		_updateAbsPath() {
			if (this._parent) {
				this._absPath = this._parent._absPath + this.absPathSep + this.id;
			} else {
				this._absPath = this.id;
			}
		}
	}

	class PageContainerBase extends PageElementBase {
		make(type, name) {
			super.make(type, name);

			const childrenArr = [];
			const childrenDict = {};
			this.__PageContainerBase_makeSelf(childrenArr, childrenDict);
		}
		__PageContainerBase_makeSelf(arr, dict) {
			this._childrenArr = arr;
			this._childrenDict = dict;
		}

		// updateAbsPath should only be true if the element will be loaded with no parent
		load(type, id, name, children, updateAbsPath = false) {
			super.load(type, id, name);

			const childrenDict = {};
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				childrenDict[child.id] = child;
				child._parent = this;
				child._parentIdx = i;
			}

			this.__PageContainerBase_makeSelf(children, childrenDict);
			if (updateAbsPath) {
				this._updateAbsPath();
			}
		}

		get numChildren() {
			return this._childrenArr.length;
		}

		getChild(pageElemID) {
			if (typeof pageElemID === "number") {
				return this._childrenArr[pageElemID];
			}

			if (typeof pageElemID === "string") {
				return this._childrenDict[pageElemID];
			}

			if (typeof pageElemID === "object" && pageElemID.__IS_PAGE_ELEMENT__) {
				return pageElemID;
			}

			throw new Error("Invalid child parameter " + pageElemID);
		}

		addChild(pageElem, idx = null) {
			if (!pageElem || !pageElem.__IS_PAGE_ELEMENT__) {
				throw new Error("PageElement cannot add non-PageElement child");
			}
			if (this._childrenDict[pageElem.id]) {
				throw new Error(\`PageElement cannot add child; id already used (are you trying to re-add child?)\`);
			}

			if (pageElem._parent) {
				pageElem._parent.removeChild(pageElem);
			}

			pageElem._parent = this;
			pageElem._updateAbsPath();
			this._childrenDict[pageElem.name] = pageElem;

			if (typeof idx === "number") {
				pageElem._parentIdx = idx;
				this._shiftChildIdxs(idx, 1);
				this._childrenArr.splice(idx, 0, pageElem);
			} else {
				pageElem._parentIdx = this._childrenArr.length;
				this._childrenArr.push(pageElem);
			}
		}

		removeChild(pageElem) {
			pageElem = this.getChild(pageElem);

			if (!pageElem || pageElem._parent !== this) {
				throw new Error(\`Cannot remove PageElement that is not a child\`);
			}

			this._childrenArr.splice(pageElem._parentIdx, 1);
			this._shiftChildIdxs(pageElem._parentIdx, -1);
			delete this._childrenDict[pageElem.name];

			pageElem._parent = null;
			pageElem._updateAbsPath();
			pageElem._parentIdx = null;
		}

		moveChild(pageElem, newIdx) {
			pageElem = this.getChild(pageElem);
			if (!pageElem || pageElem._parent !== this) {
				throw new Error(\`Cannot move PageElement that is not a child\`);
			}

			if (typeof newIdx === "string") {
				newIdx = this.getChild(newIdx)._parentIdx;
			} else if (typeof newIdx === "object") {
				newIdx = newIdx._parentIdx;
			}
			if (typeof newIdx !== "number") {
				throw new Error(\`PageElement received an invalid value for moving a child\`);
			}

			if (pageElem._parentIdx === newIdx) {
				return;
			}

			// removes child
			const oldIdx = pageElem._parentIdx;
			this._childrenArr.splice(oldIdx, 1);

			// adds child
			pageElem._parentIdx = newIdx;
			this._childrenArr.splice(newIdx, 0, pageElem);

			// shifts necessary children
			if (oldIdx < newIdx) {
				this._shiftChildIdxs(oldIdx, -1, newIdx);
			} else {
				this._shiftChildIdxs(newIdx + 1, 1, oldIdx + 1); // offsets because of the new page element in the way
			}
		}

		forChildren(func) {
			this._childrenArr.forEach(func);
		}
		mapChildren(func) {
			return this._childrenArr.map(func);
		}

		_shiftChildIdxs(start, shiftBy, end = this._childrenArr.length) {
			for (let i = start; i < end; i++) {
				const child = this._childrenArr[i];
				child._parentIdx += shiftBy;
			}
		}

		_updateAbsPath() {
			super._updateAbsPath();
			for (let i = 0; i < this._childrenArr.length; i++) {
				const child = this._childrenArr[i];
				child._updateAbsPath();
			}
		}
	}

	class PageDocableContainerBase extends PageContainerBase {
		make(type, name) {
			super.make(type, name);

			const notes = [];
			this.__PageDocableContainerBase_makeSelf(notes);
		}
		__PageDocableContainerBase_makeSelf(allNotes) {
			this._allChildNotes = allNotes;
		}

		load(type, id, name, children, updateAbsPath = false) {
			super.load(type, id, name, children, updateAbsPath);

			const allNotes = [];
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				this._addNotesFrom(child, allNotes);
			}
			this.__PageDocableContainerBase_makeSelf(allNotes);
		}

		toDoc() {
			let titles = "";
			let contents = "";
			for (let i = 0; i < this._allChildNotes.length; i++) {
				const note = this._allChildNotes[i];
				titles += note.title + ' ';
				contents += note.content + ' ';
			}

			return {
				id: this.id,
				name: this.name,
				noteTitles: titles,
				noteContents: contents,

				origElem: this // not a field, but used to grab element during search
			};
		}

		addChild(pageElem, idx = null) {
			super.addChild(pageElem, idx);
			this._addNotesFrom(pageElem);
		}

		removeChild(pageElem) {
			super.removeChild(pageElem);
			this._removeNotesFrom(pageElem);
		}

		// NOTE: this (and remove) allows specifying allNotes to allow loading patterns to work
		_addNotesFrom(pageElem, allNotes = this._allChildNotes) {
			switch (pageElem.type) {
				case "folder":
				case "notebook":
					{
						for (let i = 0; i < pageElem._allChildNotes.length; i++) {
							const note = pageElem._allChildNotes[i];
							allNotes.push(note);
						}
					}
					break;

				case "note":
					{
						allNotes.push(pageElem);
					}
					break;
			}

			// shouldnt be called on loading, since this will have no parent
			if (this._parent && this._parent._addNotesFrom) {
				this._parent._addNotesFrom(pageElem);
			}
		}

		_removeNotesFrom(pageElem, allNotes = this._allChildNotes) {
			switch (pageElem.type) {
				case "folder":
				case "notebook":
					{
						for (let i = 0; i < pageElem._allChildNotes.length; i++) {
							const note = pageElem._allChildNotes[i];
							const noteIdx = allNotes.indexOf(note);
							allNotes.splice(noteIdx, 1);
						}
					}
					break;

				case "note":
					{
						const noteIdx = allNotes.indexOf(pageElem);
						allNotes.splice(noteIdx, 1);
					}
					break;
			}

			if (this._parent && this._parent._removeNotesFrom) {
				this._parent._removeNotesFrom(pageElem);
			}
		}
	}

	class PageFolder extends PageDocableContainerBase {
		make(name) {
			super.make("folder", name);
		}

		load(id, name, children, updateAbsPath = false) {
			super.load("folder", id, name, children, updateAbsPath);
		}
	}

	class PageNotebook extends PageDocableContainerBase {
		make(name) {
			super.make("notebook", name);
		}

		load(id, name, children, updateAbsPath = false) {
			super.load("notebook", id, name, children, updateAbsPath);
		}

		addChild(pageElem, idx = null) {
			if (pageElem.type !== "note") {
				throw new Error("PageNotebook can only add PageNote children");
			}

			super.addChild(pageElem, idx);
		}
	}

	class PageNote extends PageElementBase {
		make(title, content) {
			super.make("note", title);
			this.__PageNote_makeSelf(content);
		}
		__PageNote_makeSelf(content) {
			this.content = content;
		}

		load(id, title, content) {
			super.load("note", id, title);
			this.__PageNote_makeSelf(content);
		}

		get title() {
			return this.name;
		}
		set title(val) {
			this.name = val;
		}

		toDoc() {
			return {
				id: this.id,
				title: this.title,
				content: this.content,

				origElem: this // not a field, but used to grab element during search
			};
		}
	}

	class PageElementLoader {
		static toString(elem) {
			const { type, id } = elem;
			switch (type) {
				case "folder":
				case "notebook":
					{
						const { name, _childrenArr } = elem;
						return this._generateElementString(type, id, name, _childrenArr);
					}
					break;

				case "note":
					{
						// under the assumption that note.title === note.name
						const { title, content } = elem;
						return this._generateElementString(type, id, title, content);
					}
					break;

				default:
					{
						throw new Error(\`PageElementLoader recieved an invalid type of element: \${elem.type}\`);
					}
					break;
			}
		}
		static _generateElementString(type, id, ...data) {
			if (type.includes(' ')) {
				throw new Error("(Internal PageElementLoader error): Type cannot include spaces!!!");
			}

			let str = \`E\${type} \${id}\`;
			const split = this._splitChar;
			for (let i = 0; i < data.length; i++) {
				const currData = data[i];

				if (typeof currData === "string") {
					str += split + "S" + this._validateStr(currData);
				}

				// arrays are exclusive to containers and therefore only hold page elements
				else if (Array.isArray(currData)) {
						str += split + 'A';
						const splitChild = this._splitChildChar;
						for (let j = 0; j < currData.length; j++) {
							const elem = currData[j];
							if (j > 0) {
								str += splitChild;
							}
							str += this._validateStr(this.toString(elem));
						}
					}
			}
			return str;
		}

		static fromString(str) {
			if (str[0] !== 'E') {
				throw new Error("PageElementLoader received an invalid loading string");
			}

			// NOTE: keeping track of this provides two needed outcomes: first,
			// only the first call of fromString() should finally set _isLoading
			// to false; second, this is passed to the top PageContainer,
			// which allows it to know it is the one that should update all
			// children absolute paths (which is an optimization; children will
			// know NOT to continuously update every child path)
			let thisTopCall = !PageElementBase._isLoading;
			if (thisTopCall) {
				// only first call should toggle this
				PageElementBase._isLoading = true;
			}

			const elemData = this._splitStr(str, this._splitChar);
			// this first data matches \`\${type} \${id}\`; consecutive ones must match the order they
			// were inputted when creating the string (ex. [title, content] for notes)
			const [type, id] = elemData.shift().slice(1).split(' ');
			let elem;
			switch (type) {
				case 'folder':
					{
						elem = this._createFolderElement(thisTopCall, id, elemData);
					}
					break;

				case 'notebook':
					{
						elem = this._createNotebookElement(thisTopCall, id, elemData);
					}
					break;

				case 'note':
					{
						elem = this._createNoteElement(thisTopCall, id, elemData);
					}
					break;

				default:
					{
						throw error;
					}
					break;
			}

			if (thisTopCall) {
				PageElementBase._isLoading = false;
			}
			return elem;
		}

		// allows the string to be considered 'nested' in container elements
		static _validateStr(str) {
			const split = this._splitChar;
			const child = this._splitChildChar;
			let valStr = '';
			for (let i = 0; i < str.length; i++) {
				const char = str[i];
				if (char === split || char === child) {
					valStr += '\\\\';
				}
				valStr += char;
			}
			return valStr;
		}
		// evaluates a "nested" string to the original
		static _evaluateStr(str) {
			const split = this._splitChar;
			const child = this._splitChildChar;

			let evalStr = '';
			let lastChar = '';
			for (let i = 0; i < str.length; i++) {
				const char = str[i];
				const escaped = lastChar === '\\\\' && (char === split || char === child);
				if (!escaped && lastChar !== null) {
					evalStr += lastChar;
				}
				lastChar = char;
			}
			return evalStr + lastChar;
		}

		// splits a string, ignoring "nested" strings
		static _splitStr(str, splitBy) {
			let arr = [''];
			let idx = 0;
			let lastChar = null;
			for (let i = 0; i < str.length; i++) {
				const char = str[i];

				// splits unescaped strings
				if (lastChar !== '\\\\' && char === splitBy) {
					arr.push('');
					idx++;
				}

				// adds anything that isnt splitting
				else {
						arr[idx] += char;
					}

				lastChar = char;
			}
			return arr;
		}

		static get _splitChar() {
			return ';';
		}
		static get _splitChildChar() {
			return ',';
		}
		static get _tempSplitChar() {
			return '\\u1482';
		}

		static get _loadError() {
			return new Error(\`PageElementLoader loaded an invalid string\`);
		}

		static _parseContainerBase(elemData) {
			let [name, arrStr] = elemData;
			if (name[0] !== 'S' || arrStr[0] !== 'A') {
				throw this._loadError;
			}
			name = name.slice(1);
			arrStr = arrStr.slice(1);

			name = this._evaluateStr(name);
			const elemStrs = this._splitStr(arrStr, this._splitChildChar);
			let children;
			if (arrStr !== '') {
				children = elemStrs.map(elemStr => this.fromString(this._evaluateStr(elemStr)));
			} else {
				// avoids [''] arrays (in case arrStr is 'A' with nothing after)
				children = [];
			}
			return { name, children };
		}

		static _createFolderElement(topCall, id, elemData) {
			const { name, children } = this._parseContainerBase(elemData);

			const elem = new PageFolder();
			elem.load(id, name, children, topCall); // topCall === updateAbsPath
			return elem;
		}

		static _createNotebookElement(topCall, id, elemData) {
			const { name, children } = this._parseContainerBase(elemData);

			const elem = new PageNotebook();
			elem.load(id, name, children, topCall); // topCall === updateAbsPath
			return elem;
		}

		static _createNoteElement(topCall, id, elemData) {
			let [title, content] = elemData;
			if (title[0] !== 'S' || content[0] !== 'S') {
				throw this._loadError;
			}
			title = title.slice(1);
			content = content.slice(1);

			title = this._evaluateStr(title);
			content = this._evaluateStr(content);
			const elem = new PageNote();
			elem.load(id, title, content);
			return elem;
		}
	}

	class LoadingCircle extends ReactStyles.Component {
		makeStyle(when) {
			return {
				width: "90px",
				height: "90px",
				position: "relative",

				boxSizing: "border-box",

				strokeWidth: "9px",
				fill: PRESET("clear"),

				animation: "LoadingCircleSpin 1s infinite cubic-bezier(0.49,0.2,0.51,0.8)",
				"@keyframes LoadingCircleSpin": {
					from: {
						transform: "rotate(-30deg)"
					},

					to: {
						transform: "rotate(330deg)"
					}
				},

				ellipse: {
					stroke: PRESET("softGrey", { alpha: 0.3 })
				},

				path: {
					width: "100%",
					height: "100%",
					position: "absolute",
					top: "0px",
					left: "0px",

					stroke: PRESET("activeBlue"),
					transformOrigin: "center center",

					[when("alt0")]: {
						animation: "LoadingCircleSquish0 1s infinite cubic-bezier(0.49,0.1,0.51,0.8)",
						"@keyframes LoadingCircleSquish0": {
							50: {
								transform: "rotate(40deg)"
							}
						}
					},

					[when("alt1")]: {
						animation: "LoadingCircleSquish1 1s infinite cubic-bezier(0.49,0.2,0.51,0.7)",
						"@keyframes LoadingCircleSquish1": {
							50: {
								transform: "rotate(-40deg)"
							}
						}
					}
				}
			};
		}

		render() {
			const r = 43;
			const xStart = 50;
			const yStart = 50 - r;
			const xEnd = 50 + 3 * r / 4;
			const yEnd = 50 - r * Math.sin(Math.acos(3 / 4));
			return React.createElement(
				"svg",
				{ viewBox: "0 0 100 100" },
				React.createElement("ellipse", { cx: "50", cy: "50", rx: r, ry: r }),
				React.createElement("path", { d: \`M \${xStart},\${yStart} A \${r},\${r} 0 0,1 \${xEnd},\${yEnd}\` }),
				React.createElement("path", { d: \`M \${xStart},\${yStart} A \${r},\${r} 0 0,1 \${xEnd},\${yEnd}\`, className: "alt0" }),
				React.createElement("path", { d: \`M \${xStart},\${yStart} A \${r},\${r} 0 0,1 \${xEnd},\${yEnd}\`, className: "alt1" })
			);
		}
	}

	if (false) {
		class Container extends ReactStyles.Component {
			makeStyle(when) {
				return {
					"=body": {
						backgroundColor: PRESET("deepNavy", { alpha: 1 })
					}
				};
			}

			render() {
				return React.createElement(LoadingCircle, null);
			}
		}

		ReactDOM.render(React.createElement(Container, null), root);
	}

	class SVGIcon extends ReactStyles.Component {
		static get icons() {
			let icons = [];
			for (const icon in this._iconMap) {
				icons.push(icon);
			}
			return icons;
		}

		static get _iconMap() {
			if (!this.__iconMap) {
				this.__iconMap = {
					blank: this.renderBlank(),
					bars: this.renderBars(),
					magGlass: this.renderMagGlass(),
					backArrow: this.renderBackArrow(),
					plus: this.renderPlus()
				};
			}
			return this.__iconMap;
		}

		constructor(props) {
			super(props);

			const check = this.addCheckForProp;
			check("type", "typeof", "string");
		}

		makeStyle(when) {
			return {
				position: "relative",
				width: "100%",
				height: "100%",

				svg: {
					position: "absolute",
					top: "0px",
					left: "0px",

					width: "100%",
					height: "100%",
					backgroundColor: PRESET("clear"),

					stroke: PRESET("softWhite"),
					strokeWidth: "5px",
					fill: PRESET("clear")
				}
			};
		}

		render() {
			const { type } = this.props;
			const svgRender = SVGIcon._iconMap[type];
			if (!svgRender) {
				throw new Error(\`Icon '\${type}' is invalid\`);
			}
			return React.createElement(
				"div",
				null,
				svgRender
			);
		}

		static renderBlank() {
			return React.createElement("svg", null);
		}

		static renderBars() {
			const posXs = [20, 80];
			const posYs = [30, 50, 70];

			return React.createElement(
				"svg",
				{ viewBox: "0 0 100 100" },
				React.createElement("line", { x1: posXs[0], x2: posXs[1], y1: posYs[0], y2: posYs[0] }),
				React.createElement("line", { x1: posXs[0], x2: posXs[1], y1: posYs[1], y2: posYs[1] }),
				React.createElement("line", { x1: posXs[0], x2: posXs[1], y1: posYs[2], y2: posYs[2] })
			);
		}

		static renderMagGlass() {
			return React.createElement(
				"svg",
				{ viewBox: "0 0 100 100" },
				React.createElement("ellipse", { cx: 60, cy: 40, rx: 20, ry: 20 }),
				React.createElement("line", { x1: 20, y1: 80, x2: 45, y2: 55 })
			);
		}

		static renderBackArrow() {
			// offset calculation is used to create a nice, crisp point with the pyth-theo
			const strokeWidth = 5; // in pixels
			const offset = strokeWidth * 2 ** (1 / 2) / 4;

			return React.createElement(
				"svg",
				{ viewBox: "0 0 100 100" },
				React.createElement("line", { x1: 23 - offset, y1: 50 + offset, x2: 46, y2: 26 }),
				React.createElement("line", { x1: 23, y1: 50, x2: 77, y2: 50 }),
				React.createElement("line", { x1: 23 - offset, y1: 50 - offset, x2: 46, y2: 74 })
			);
		}

		static renderPlus() {
			return React.createElement(
				"svg",
				{ viewBox: "0 0 100 100" },
				React.createElement("line", { x1: 23, y1: 50, x2: 77, y2: 50 }),
				React.createElement("line", { x1: 50, y1: 23, x2: 50, y2: 77 })
			);
		}
	}

	if (false) {
		class Container extends ReactStyles.Component {
			makeStyle() {
				return React.createElement(
					"style",
					null,
					\`
				.Container {
					width: 100%;
					height: 300px;
					
					display: flex;
					flex-flow: row wrap;
				}
				.Container button {
					width: 150px;
					height: 150px;
					padding: 0px;
					background-color: rgba(10, 50, 120, 0.5);
					border: none;
					margin: 8px;
				}
				.Container 
			\`
				);
			}

			render() {
				return React.createElement(
					"div",
					null,
					this.renderIcons()
				);
			}

			renderIcons() {
				let icons = [];
				for (const icon of SVGIcon.icons) {
					icons.push(React.createElement(
						"button",
						null,
						React.createElement(SVGIcon, { type: icon })
					));
				}
				return icons;
			}
		}

		ReactDOM.render(React.createElement(Container, null), root);
	}

	class TopBar extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				searchActive: false,
				sliding: false,
				menuHidden: true
			};

			this._searchFocusRef = React.createRef();
			this._menuClicked = false;

			const check = this.addCheckForProp;
			check("menuContent", "possible-typeof", "object");
			check("forceMenuHidden", "possible-typeof", "boolean");

			check("selectedIdx", "possible-typeof", "number");
			check("onButtonClick", "possible-typeof", "function");
			check("onSearchInactive", "possible-typeof", "function");
			check("onSearchActive", "possible-typeof", "function");
			check("onSearchClick", "possible-typeof", "function");
		}

		makeStyle(when) {
			return {
				position: "relative",

				width: "100%",
				boxSizing: "border-box",
				backgroundColor: PRESET("softNavy"),
				padding: "0px 5px",

				display: "flex",
				flexFlow: "row nowrap",
				justifyContent: "space-between",

				'*': {
					[when(":focus")]: {
						outline: "none"
					},
					[when("::-moz-focus-inner")]: {
						border: "none"
					}
				},

				AnimationBounds: {
					overflow: "hidden", // keeps animations inside the bar, but not the menu!

					position: "absolute",
					top: "0px",
					right: "0px",
					width: "100%",
					height: "100%"
				},

				Spacer: {
					flex: 1,
					minWidth: "5px" // guarantees a margin of 5px
				},

				Main: {
					position: "absolute",
					top: "0px",
					right: "5px",

					width: "75%",
					display: "flex",
					flexFlow: "row nowrap",
					justifyContent: "space-between",
					alignItems: "center",

					animation: "TopBar-FadeOut 0.3s forwards, TopBar-SlideLeft 0.3s forwards",
					// wont work as a generic * class
					[when("Uncollapsed")]: {
						animationName: "TopBar-FadeIn, TopBar-UnslideLeft",
						animationTimingFunction: "ease-out"
					},

					[when("Collapsed")]: {
						opacity: 0,
						pointerEvents: "none",
						animationTimingFunction: "ease-in"
					}
				},

				Search: {
					position: "absolute",
					top: "0px",
					right: "5px",

					width: "75%",
					display: "flex",
					flexFlow: "row nowrap",
					justifyContent: "space-between",

					animation: "TopBar-FadeOut 0.3s forwards, TopBar-SlideRight 0.3s forwards",

					// wont work as a generic * class
					[when("Uncollapsed")]: {
						animationName: "TopBar-FadeIn, TopBar-UnslideRight",
						animationTimingFunction: "ease-out"
					},

					[when("Collapsed")]: {
						opacity: 0,
						pointerEvents: "none",
						animationTimingFunction: "ease-in"
					}
				},

				"@keyframes TopBar-FadeOut": {
					from: {
						opacity: 1
					},
					55: {
						opacity: 0
					},
					to: {
						opacity: 0
					}
				},
				"@keyframes TopBar-FadeIn": {
					from: {
						opacity: 0
					},
					45: {
						opacity: 0
					},
					to: {
						opacity: 1
					}
				},

				"@keyframes TopBar-SlideLeft": {
					to: {
						transform: "translateX(-220px)"
					}
				},
				"@keyframes TopBar-UnslideLeft": {
					from: {
						transform: "translateX(-220px)"
					}
				},

				"@keyframes TopBar-SlideRight": {
					to: {
						transform: "translateX(220px)"
					}
				},
				"@keyframes TopBar-UnslideRight": {
					from: {
						transform: "translateX(220px)"
					}
				},

				TopBarMenu: {
					position: "absolute",
					top: "100%",
					left: "10px"
				}
			};
		}

		static getDerivedStateFromProps(props, state) {
			if (typeof props.forceMenuHidden === "boolean") {
				state.menuHidden = props.forceMenuHidden;
			}
			return state;
		}

		shouldComponentUpdate(nextProps, nextState) {
			return true;
		}

		render() {
			const buttons = ["Ques", "Less", "Disc"];

			// the order is weird because the animation bounds need to be "behind" the menu
			return React.createElement(
				"div",
				{ className: "TopBar" },
				React.createElement(
					"div",
					{ className: "AnimationBounds" },
					React.createElement(
						"div",
						{
							className: \`Main \${this.state.searchActive ? "Collapsed" : "Uncollapsed"}\`,
							style: {
								animationDuration: this.state.sliding ? null : "0s"
							}
						},
						buttons.map((button, idx) => this.renderButton(button, idx)),
						React.createElement(TopBarIconButton, {
							onClick: () => {
								this.setState({ searchActive: true, sliding: true });
								setTimeout(() => this.props.onSearchActive()); // allows animation to play first
							},
							icon: React.createElement(SVGIcon, { type: "magGlass" })
						})
					),
					React.createElement(
						"div",
						{
							className: \`Search \${this.state.searchActive ? "Uncollapsed" : "Collapsed"}\`,
							style: {
								animationDuration: this.state.sliding ? null : "0s"
							},
							onAnimationEnd: () => {
								this.setState({ sliding: false });
								if (this.state.searchActive) {
									this._searchFocusRef.current.focus();
								}
							}
						},
						React.createElement(TopBarIconButton, {
							onClick: () => {
								this.setState({ searchActive: false, sliding: true });
								setTimeout(() => this.props.onSearchInactive()); // allows animation to play first
							},
							icon: React.createElement(SVGIcon, { type: "backArrow" })
						}),
						React.createElement("div", { className: "Spacer" }),
						React.createElement(TopBarSearchBar, { ref: this._searchFocusRef, onSearchClick: val => this.props.onSearchClick(val) })
					)
				),
				React.createElement(TopBarIconButton, { icon: React.createElement(SVGIcon, { type: "bars" }), onClick: () => {
						this.setState({ menuHidden: !this.state.menuHidden });
						this._menuClicked = true;
					} }),
				React.createElement(
					TopBarMenu,
					{ hidden: this.state.menuHidden, onClick: () => this._menuClicked = true },
					this.props.menuContent
				)
			);
		}

		renderButton(button, idx) {
			const onClick = () => this.clickButton(idx, button);
			const selected = idx === this.props.selectedIdx;

			let result;
			if (typeof button === "string") {
				result = React.createElement(TopBarButton, { name: button, selected: selected, onClick: onClick });
			} else if (typeof button === "object") {
				result = React.createElement(TopBarIconButton, { icon: button, selected: selected, onClick: onClick });
			}

			return [result, React.createElement("div", { className: "Spacer" })];
		}

		componentDidMount() {
			window.addEventListener("click", () => {
				if (!this._menuClicked && !this.state.menuHidden) {
					this.setState({ menuHidden: true });
				}
				this._menuClicked = false;
			});
		}

		clickButton(idx) {
			if (typeof this.props.onButtonClick === "function") {
				this.props.onButtonClick(idx);
			}
		}
	}

	class TopBarButton extends ReactStyles.Component {
		constructor(props) {
			super(props);

			const check = this.addCheckForProp;
			check("onClick", "possible-typeof", "function");
			check("selected", "possible-typeof", "boolean");
		}

		makeStyle(when) {
			return {
				backgroundColor: PRESET("clear"),
				height: "40px",
				padding: "0px 10px",

				color: PRESET("softWhite"),
				border: "none",

				margin: "0px 0px",
				fontSize: "calc(15px + 0.16em)",

				[when(".selected")]: {
					backgroundColor: PRESET("activeShadow", { alpha: 0.27 })
				},

				[when(":active")]: {
					backgroundColor: PRESET("activeNightBlue")
				}
			};
		}

		render() {
			return React.createElement(
				"button",
				{ className: \`TopBarButton \${this.props.selected ? "selected" : ''}\`, onClick: this.props.onClick },
				this.props.name
			);
		}
	}

	class TopBarIconButton extends ReactStyles.Component {
		constructor(props) {
			super(props);

			const check = this.addCheckForProp;
			check("selected", "possible-typeof", "boolean");
			check("onClick", "possible-typeof", "function");
			check("icon", "possible-componentof", SVGIcon);
		}

		makeStyle(when) {
			return {
				backgroundColor: PRESET("clear"),
				height: "40px",

				position: "relative",
				padding: "0px 7px",

				[when(".selected")]: {
					backgroundColor: PRESET("activeShadow", { alpha: 0.27 })
				},

				[when(":active")]: {
					backgroundColor: PRESET("activeNightBlue")
				},

				button: {
					width: "40px",
					height: "40px",
					padding: "0px",

					backgroundColor: PRESET("clear"),
					border: "none"

				}
			};
		}

		render() {
			return React.createElement(
				"div",
				{ className: \`TopBarIconButton \${this.props.selected ? "selected" : ''}\` },
				React.createElement(
					"button",
					{ onClick: this.props.onClick },
					this.props.icon
				)
			);
		}
	}

	// a completely controlled component (hidden is a derived state)
	class TopBarMenu extends ReactStyles.Component {
		constructor(props) {
			super(props);
			this.disableHiddenProp();

			this.state = {
				lastHidden: null,
				animating: false
			};

			const check = this.addCheckForProp;
			check("hidden", "typeof", "boolean");
			check("onClick", "possible-typeof", "function");
		}

		makeStyle(when) {
			return {
				width: "200px",
				height: "300px",
				backgroundColor: PRESET("ghostNavy"),

				zIndex: 10,

				display: "flex",
				flexFlow: "row wrap",
				justifyContent: "space-around",
				alignItems: "center",

				animation: "TopBarMenu-FadeIn 0.22s forwards",
				animationTimingFunction: "ease-out",

				[when("hiding")]: {
					animationName: "TopBarMenu-FadeOut",
					animationTimingFunction: "ease-in"
				},

				"@keyframes TopBarMenu-FadeOut": {
					from: {
						opacity: 1
					},

					to: {
						opacity: 0,
						transform: "translateY(-50%) scaleY(0)"
					}
				},
				"@keyframes TopBarMenu-FadeIn": {
					from: {
						opacity: 0,
						transform: "translateY(-50%) scaleY(0)"
					},

					to: {
						opacity: 1
					}
				},

				'>*': {
					margin: "0px",
					width: "35%",
					height: "26px",

					lineHeight: "24px",

					color: PRESET("softWhite")
				},

				Shadow: {
					height: "15px",
					width: "100%",

					position: "absolute",
					top: "0px",
					left: "0px",

					backgroundImage: \`linear-gradient(
					to bottom,
					\${PRESET("softBlack", { alpha: 0.3 })},
					\${PRESET("softBlack", { alpha: 0.1 })},
					\${PRESET("clear")}
				)\`
				},

				'>button': {
					fontSize: "9pt",
					padding: "0px",

					border: "none",
					backgroundColor: PRESET("softNavy", { alpha: 0.5 }),

					[when(":active")]: {
						backgroundColor: PRESET("activeNightBlue")
					},

					[when(":disabled")]: {
						border: "none",
						backgroundColor: PRESET("darkGrey"),
						opacity: 0.8
					}
				},

				">p": {
					fontSize: "17px",
					textAlign: "left",
					position: "relative",
					left: "-6px",
					whiteSpace: "nowrap"
				}
			};
		}

		static getDerivedStateFromProps(props, state) {
			if (state.lastHidden === null) {
				state.lastHidden = props.hidden;
			} else if (state.lastHidden !== props.hidden) {
				state.animating = true;
				state.lastHidden = props.hidden;
			}
			return state;
		}

		render() {
			return React.createElement(
				"div",
				{
					className: \`TopBarMenu \${this.props.hidden ? "hiding" : ""}\`,
					style: {
						animationDuration: this.state.animating ? null : "0s"
					},
					onClick: this.props.onClick,
					onAnimationEnd: () => this.setState({ animating: false })
				},
				React.createElement("div", { className: "Shadow" }),
				this.props.children
			);
		}
	}

	class TopBarSearchBar extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this._inputRef = React.createRef();

			const check = this.addCheckForProp;
			check("onSearchClick", "possible-typeof", "function");
		}

		focus() {
			this._inputRef.current.focus();
		}

		blur() {
			this._inputRef.current.blur();
		}

		makeStyle(when) {
			return {
				width: "100%",
				height: "40px",

				backgroundColor: PRESET("clear"),

				display: "flex",
				justifyContent: "center",
				alignItems: "center",

				input: {
					width: "90%",
					height: "50%",
					backgroundColor: PRESET("softWhite"),
					color: PRESET("softBlack"),

					padding: "1px 5px",
					border: "none",
					borderRadius: "6px 0px 0px 6px"
				},

				SearchButton: {
					// these values are flush with the search bar
					minWidth: "22px",
					height: "22px",
					backgroundColor: PRESET("softWhite"),
					margin: "0px",

					border: "none",
					borderRadius: "0px 6px 6px 0px",

					display: "flex",
					alignItems: "center",

					button: {
						position: "relative",
						left: "-1.5px",

						width: "19px",
						height: "19px",
						padding: "0px", // keeps icon at its full size

						border: "none",
						borderRadius: "100px",
						backgroundColor: PRESET("clear"),

						svg: {
							stroke: PRESET("softBlack")
						}
					},

					[when(":active")]: {
						button: {
							backgroundColor: PRESET("activeShadow", { alpha: 0.4 })
						}
					}
				}
			};
		}

		render() {
			return React.createElement(
				"div",
				null,
				React.createElement("input", {
					ref: this._inputRef,
					onFocus: () => this._inputRef.current.select(),
					onKeyDown: event => {
						if (event.key === "Enter") {
							event.preventDefault();
							this.triggerSearchClick();
						}
					}
				}),
				React.createElement(
					"div",
					{ className: "SearchButton" },
					React.createElement(
						"button",
						{ onClick: () => this.triggerSearchClick() },
						React.createElement(SVGIcon, { type: "magGlass" })
					)
				)
			);
		}

		triggerSearchClick() {
			if (typeof this.props.onSearchClick === "function") {
				const elem = this._inputRef.current;
				const text = elem.value;
				this.blur();
				this.props.onSearchClick(text);
			}
		}
	}

	if (false) {
		// NOTE: this test includes using the "menuHidden" prop, which is optional; ensure the component works without using this
		class Container extends ReactStyles.Component {
			constructor(props) {
				super(props);
				this.state = {
					selected: 0,
					forceMenuHidden: null,
					collapsed: false
				};
			}

			makeStyle(when) {
				return React.createElement(
					"style",
					null,
					\`
				.Container {
					position: absolute;
					top: 0px;
					left: 0px;
					width: 97%;
					padding: 3px;
					box-sizing: border-box;
				}
			\`
				);
			}

			render() {
				return React.createElement(
					"div",
					null,
					React.createElement(TopBar, {
						onSearchInactive: () => {
							for (let i = 0; i < 50; i++) {
								const cons = console;
								cons.log("TEST");
							}
						},
						selectedIdx: this.state.selected,
						onMenuToggle: () => this.toggleMenu(),
						forceMenuHidden: this.state.forceMenuHidden,
						menuContent: [React.createElement("button", null), React.createElement(
							"p",
							null,
							"thing"
						), React.createElement("button", null), React.createElement(
							"button",
							{ onClick: () => this.setState({ forceMenuHidden: true }) },
							"test"
						), React.createElement("button", null), React.createElement(
							"button",
							null,
							"cackle"
						), React.createElement(
							"p",
							null,
							"thing"
						), React.createElement(
							"button",
							null,
							"cackle"
						), React.createElement(
							"p",
							null,
							"thing"
						), React.createElement("button", null), React.createElement(
							"button",
							null,
							"cackle"
						), React.createElement(
							"p",
							null,
							"thing"
						)],
						onButtonClick: idx => this.setState({ selected: idx }),
						onSearchClick: text => alert(\`searched: '\${text || ' '}'\`)
					})
				);
			}

			componentDidUpdate() {
				if (typeof this.state.forceMenuHidden === "boolean") {
					this.setState({ forceMenuHidden: null });
				}
			}
		}

		ReactDOM.render(React.createElement(Container, null), root);
	}

	class Draggable extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this._dragRef = React.createRef();

			this.state = {
				initHoldX: null, // type: number or null
				initHoldY: null
			};

			this._currentHoldType = null;
			this._holdTimeout = null;
			this._holdCancelTimeout = null;
			this._preventTouchScroll = false;

			const check = this.addCheckForProp;
			check("dragRef", "possible-typeof", "object");
			check("beforeDrag", "possible-typeof", "function");
			check("onDrag", "possible-typeof", "function");
			check("afterDrag", "possible-typeof", "function");
		}

		makeStyle(when) {
			const maxHeight = 150;
			const maxWidth = 500;
			const scale = 0.9;

			return {
				[when("holding")]: {
					// NOTE: separate container used to allow transform coordinates not to be scaled
					ScaleContainer: {
						transformOrigin: () => {
							if (this.state.initHoldX === null) {
								return "0% 0%";
							}

							const rect = this._dragRef.current.getBoundingClientRect();
							const relX = this.state.initHoldX - rect.left;
							const relY = this.state.initHoldY - rect.top;
							return \`\${relX}px \${relY}px\`;
						},
						animation: "DraggableShrink 0.2s forwards",
						"@keyframes DraggableShrink": {
							to: {
								transform: () => \`scale(\${scale * Math.min(1, maxWidth / this._dragRef.current.clientWidth)}, \${scale * Math.min(1, maxHeight / this._dragRef.current.clientHeight)})\`
							}
						}
					}
				}
			};
		}

		render() {
			return React.createElement(
				"div",
				{ ref: this._dragRef, className: typeof this.state.initHoldX === "number" ? "Draggable holding" : "Draggable" },
				React.createElement(
					"div",
					{ className: "ScaleContainer" },
					this.props.children
				)
			);
		}

		componentDidMount() {
			// touchmove has to be bound here to pass {passive: false} (which prevents scrolling)
			const elem = this._dragRef.current;
			elem.addEventListener("touchend", event => this._endHold(event, "touch"), { passive: false });
			elem.addEventListener("touchmove", event => this._moveHold(event, "touch"), { passive: false });
			elem.addEventListener("touchstart", event => this._startHold(event, "touch"), { passive: false });

			// not sure if this helps at all...
			elem.addEventListener("pointerMove", event => {
				if (this._preventTouchScroll) {
					event.preventDefault();
				}
			}, { passive: false });

			// use {passive:false} here... because I want to prevent it?
			elem.addEventListener("mouseup", event => this._endHold(event, "mouse"), { passive: false });
			elem.addEventListener("mousemove", event => this._moveHold(event, "mouse"), { passive: false });
			elem.addEventListener("mousedown", event => this._startHold(event, "mouse"), { passive: false });

			this._resetTransOffset();
			this._updateDragRef();
		}

		componentDidUpdate() {
			this._updateDragRef();
		}

		_resetTransOffset() {
			this._transOffsetX = 0;
			this._transOffsetY = 0;
			this._dragRef.current.style.transform = null;

			this._moveBeforeReadyX = null;
			this._moveBeforeReadyY = null;
		}

		_startHold(event, eventType) {
			if (this._currentHoldType) {
				return;
			}

			let initHoldX, initHoldY;
			if (eventType === "touch") {
				const { clientX, clientY } = event.touches[0];
				initHoldX = clientX;
				initHoldY = clientY;
			} else if (eventType === "mouse") {
				const { offsetX, offsetY } = event;
				initHoldX = offsetX;
				initHoldY = offsetY;
			} else {
				throw new Error("Invalid draggable event type");
			}
			this._currentHoldType = eventType;

			this._holdTimeout = setTimeout(async () => {
				await this.setState({ initHoldX, initHoldY });
				this._callOnDrag(initHoldX, initHoldY);
			}, 160);

			this._moveBeforeReadyX = null;
			this._moveBeforeReadyY = null;

			// NOTE: when holding for 0.5 seconds, the "contextmenu" event is fired, preventing further
			// control over preventing default scrolling actions; this cancels the drag operation after
			// the context event fires (bugs arise when applying to the event itself...)
			this._holdCancelTimeout = setTimeout(() => this._endHold(event, eventType), 465);

			this.props.beforeDrag(initHoldX, initHoldY);
		}

		_endHold(event, eventType) {
			if (eventType !== this._currentHoldType) {
				return;
			}

			// tests for holdtimeout (in case moveHold() ends before holdCancelTimeout)
			if (this._holdTimeout !== null) {
				if (typeof this.state.initHoldX === "number") {
					this.setState({ initHoldX: null, initHoldY: null });

					this._resetTransOffset();
				}
				this._preventTouchScroll = false;
				clearTimeout(this._holdTimeout);
				this._holdTimeout = null;

				clearTimeout(this._holdCancelTimeout);
				this._holdCancelTimeout = null;

				this._currentHoldType = null;

				this.props.afterDrag();
			}
		}

		_moveHold(event, eventType) {
			if (eventType !== this._currentHoldType) {
				return;
			}

			let holdX, holdY;
			if (eventType === "touch") {
				const { clientX, clientY } = event.touches[0];
				holdX = clientX;
				holdY = clientY;
			} else if (eventType === "mouse") {
				const { offsetX, offsetY } = event;
				holdX = offsetX;
				holdY = offsetY;
			} else {
				throw new Error("Invalid draggable event type");
			}

			if (typeof this.state.initHoldX === "number") {
				event.preventDefault(); // prevents default touch scrolling actions
				this._preventTouchScroll = true;

				if (this._holdCancelTimeout !== null) {
					clearTimeout(this._holdCancelTimeout);
					this._holdCancelTimeout = null;
				}

				this._updateTransformStyle(holdX, holdY);
				this._callOnDrag(holdX, holdY); // fine if it errors here
			}

			// dont move finger before drag is ready!
			else if (this._moveBeforeReadyX !== null && (this._moveBeforeReadyX !== holdX || this._moveBeforeReadyY !== holdY)) {
					this._endHold(event, eventType);
				} else if (this._moveBeforeReadyX === null) {
					this._moveBeforeReadyX = holdX;
					this._moveBeforeReadyY = holdY;
				}
		}

		_updateTransformStyle(clientX, clientY) {
			const transX = clientX - this.state.initHoldX + this._transOffsetX;
			const transY = clientY - this.state.initHoldY + this._transOffsetY;
			this._dragRef.current.style.transform = "translate(" + transX + "px, " + transY + "px)";
		}

		_updateDragRef() {
			if (typeof this.props.dragRef === "object") {
				this.props.dragRef.current = this._dragRef.current;
			} else if (typeof this.props.dragRef === "function") {
				this.props.dragRef(this._dragRef.current);
			}
		}

		_callOnDrag(clientX, clientY) {
			if (typeof this.props.onDrag === "function") {
				const addOffset = (x, y) => {
					this._transOffsetX += x;
					this._transOffsetY += y;
					this._updateTransformStyle(clientX, clientY);
				};
				this.props.onDrag(clientX, clientY, addOffset);
			}
		}
	}

	if (false) {
		const mainRef = React.createRef();
		const refS = React.createRef();
		const refB = React.createRef();
		class ContainerThing extends ReactStyles.Component {
			constructor(props) {
				super(props);

				this.state = {
					text: "test"
				};
			}

			render() {
				return React.createElement(
					"div",
					null,
					React.createElement(
						Draggable,
						{ dragRef: refS, beforeDrag: () => setTimeout(() => mainRef.current.setState({ text: "TEST" }), 600) },
						React.createElement(
							"div",
							{ style: { width: "100px", height: "100px", backgroundColor: "rgba(0,0,255,0.3)" } },
							this.state.text
						)
					),
					React.createElement(
						Draggable,
						{ dragRef: refB },
						React.createElement("div", { style: { width: "300px", height: "300px", backgroundColor: "rgba(255,0,0,0.3)" } })
					)
				);
			}
		}

		ReactDOM.render(React.createElement(ContainerThing, { ref: mainRef }), root);

		const update = (ref, colorElem) => {
			ref = ref.current.children[0];
			const rect = ref.getBoundingClientRect();
			colorElem.style.height = rect.height + "px";
			colorElem.style.width = rect.width + "px";
			colorElem.style.position = "absolute";
			colorElem.style.top = rect.top + "px";
			colorElem.style.left = rect.left + "px";
		};
		const small = document.createElement("div");
		small.style["background-color"] = "rgba(0,0,255,0.6)";
		small.style["z-index"] = -999;
		const big = document.createElement("div");
		big.style["background-color"] = "rgba(255,0,0,0.6)";
		big.style["z-index"] = -999;
		document.body.appendChild(small);
		document.body.appendChild(big);
		setInterval(() => {
			update(refS, small);
			update(refB, big);
		}, 10);
	}

	class Holdable extends ReactStyles.Component {
		constructor(props) {
			super(props);

			const check = this.addCheckForProp;
			check("onHold", "possible-typeof", "function");
		}

		render() {
			return React.createElement(
				"div",
				{
					onTouchStart: event => this._startTouchHold(event),
					onTouchEnd: event => this._cancelTouchHold(event),
					onTouchMove: event => this._cancelTouchHold(event),
					onMouseDown: event => this._startMouseHold(event),
					onMouseUp: event => this._cancelMouseHold(event),
					onMouseMove: event => this._cancelMouseHold(event)
				},
				this.props.children
			);
		}

		// keeps touch events seperate from their pair mouse events (to avoid repeating function calls)
		_startTouchHold(event) {
			clearTimeout(this._updateHoldIsTouchTimeout);
			this._holdIsTouch = true;
			this._startMouseHold(event, true);
		}
		_cancelTouchHold(event) {
			this._cancelMouseHold(event, true);
			clearTimeout(this._updateHoldIsTouchTimeout);
			this._updateHoldIsTouchTimeout = setTimeout(() => this._holdIsTouch = false, 1000); // after onHold() timeout
		}

		_startMouseHold(event, isTouch = false) {
			if (isTouch || !this._holdIsTouch) {
				this._holdTimeout = setTimeout(() => this.props.onHold(), 600);
				this._lastTouch = null;
			}
		}
		_cancelMouseHold(event, isTouch = false) {
			if (isTouch || !this._holdIsTouch) {
				// NOTE: sometimes touchMove is activated when it is still, so this detects if there was actually a move
				if (event.touches[0]) {
					const { clientX, clientY } = event.touches[0];
					if (!this._lastTouch) {
						this._lastTouch = { x: clientX, y: clientY };
						return;
					} else if (this._lastTouch.x === clientX && this._lastTouch.y === clientY) {
						return;
					}
				}
				clearTimeout(this._holdTimeout);
			}
		}
	}

	class DropdownAnimationGroup extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				animationDirection: "raising", // type: "dropping" or "raising"
				animatingElement: null
			};

			this._groupRef = React.createRef();
		}

		makeStyle(when) {
			// NOTE: all animations that need access to the dynamic height go here so
			// they can all be updated in sync with each other
			return {
				DropdownGroup_Child: {
					[when("DropdownGroup_dropping")]: {
						animation: "DropdownGroup_droppingAnimation 0.33s"
					},
					"@keyframes DropdownGroup_droppingAnimation": {
						from: {
							transform: () => {
								const elem = this.state.animatingElement;
								if (elem === null) {
									return '';
								}
								const contentElem = this._getContentOfDropdown(elem);
								const height = (contentElem || {}).offsetHeight;
								return \`translateY(-\${height + 6}px)\`;
							}
						}
					},

					[when("DropdownGroup_raising")]: {
						animation: "DropdownGroup_raisingAnimation 0.33s"
					},
					"@keyframes DropdownGroup_raisingAnimation": {
						to: {
							transform: () => {
								const elem = this.state.animatingElement;
								if (elem === null) {
									return '';
								}
								const contentElem = this._getContentOfDropdown(elem);
								const height = (contentElem || {}).offsetHeight;
								return \`translateY(-\${height + 6}px)\`;
							}
						}
					},

					BottomBar: {
						"@keyframes BottomBar_undropShiftAnimation": {
							to: {
								opacity: 0,
								transform: () => {
									const elem = this.state.animatingElement;
									if (elem === null) {
										return '';
									}
									const contentElem = this._getContentOfDropdown(elem);
									const height = (contentElem || {}).offsetHeight;
									return \`translateY(-\${height + 6}px)\`;
								}
							}
						},
						"@keyframes BottomBar_dropShiftAnimation": {
							from: {
								opacity: 0,
								transform: () => {
									const elem = this.state.animatingElement;
									if (elem === null) {
										return '';
									}
									const contentElem = this._getContentOfDropdown(elem);
									const height = (contentElem || {}).offsetHeight;
									return \`translateY(-\${height + 6}px)\`;
								}
							}
						}
					}
				}
			};
		}

		render() {
			return React.createElement(
				"div",
				{ ref: this._groupRef },
				this._wrapChildren()
			);
		}

		componentDidUpdate() {
			this._updateAllChildClasses();
		}

		_wrapChildren() {
			this._trackDropdownBars(this.props.children);
			return this.props.children;
		}

		// NOTE: some children are dynamically generated and dropdown bars wont be available on
		// render; in this case, the component class should provide a truthy static "animateAsDropdownBar"
		// property and utilize needed private props (like _beforeDrop)
		_trackDropdownBars(children) {
			if (!Array.isArray(children)) {
				children = [children];
			}

			for (let idx = 0; idx < children.length; idx++) {
				const child = children[idx];
				if (typeof child === "object" && child !== null) {
					const shouldTrack = child.type === DropdownBar || child.type.animateAsDropdownBar;
					if (shouldTrack) {
						child.props._beforeDrop = (elem, dropped) => {
							this._whenChildDrops(elem, dropped);
						};
					} else if (child.props.children) {
						this._trackDropdownBars(child.props.children);
					}
				}
			}
		}

		// "dropped" determines animation direction; "barIdx" determines which dropdown bar is tracked
		_whenChildDrops(animatingElement, startedDropped) {
			const animationDirection = startedDropped ? "raising" : "dropping";
			this.setState({ animationDirection, animatingElement });
		}

		_getContentOfDropdown(elem) {
			return elem.children[1];
		}

		// NOTE: the ONLY way to guarantee correct animating is by having access to all DOM elements involved
		_updateAllChildClasses() {
			const activeDropdown = this.state.animatingElement;
			if (!activeDropdown) {
				return; // initialized and not animating yet
			}

			const direction = this.state.animationDirection;
			if (direction === this._lastAnimationDirection && activeDropdown === this._lastAnimatedElement) {
				return; // only animate for changes
			}
			this._lastAnimationDirection = direction;
			this._lastAnimatedElement = activeDropdown;

			this._updateSiblingAndParentClasses(activeDropdown, direction);
		}

		_updateSiblingAndParentClasses(elem, direction) {
			const parent = elem.parentElement;
			const elemIdx = this._getChildIdx(elem);

			for (let idx = 0; idx < parent.children.length; idx++) {
				const child = parent.children[idx];
				// sets previous children (and self) with no animation
				if (idx <= elemIdx) {
					this._setAnimClasses(child, null);
				}
				// sets children after with the animation
				else {
						this._setAnimClasses(child, direction);
					}
			}

			// performs the same operations on the parent until hitting the group
			if (parent !== this._groupRef.current) {
				this._updateSiblingAndParentClasses(parent, direction);
			}
		}

		_getChildIdx(elem) {
			let idx = 0;
			while (elem = elem.previousSibling) {
				idx++;
			}
			return idx;
		}

		_setAnimClasses(elem, state) {
			elem.addEventListener("animationend", () => {
				// ensures that the same animation can re-run multiple times
				elem.classList.remove("DropdownGroup_dropping", "DropdownGroup_raising");
			}, { once: true });

			switch (state) {
				case "dropping":
					{
						elem.classList.add("DropdownGroup_Child", "DropdownGroup_dropping");
						elem.classList.remove("DropdownGroup_raising");
					}
					break;

				case "raising":
					{
						elem.classList.add("DropdownGroup_Child", "DropdownGroup_raising");
						elem.classList.remove("DropdownGroup_dropping");
					}
					break;

				default:
					{
						elem.classList.add("DropdownGroup_Child");
						elem.classList.remove("DropdownGroup_dropping", "DropdownGroup_raising");
					}
					break;
			}
		}
	}

	class DropdownBar extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				dropped: false,
				barAnimating: false
			};

			this._ref = React.createRef();
			this._holdIsTouch = false;

			const check = this.addCheckForProp;
			check("title", "possible-typeof", "string");
			check("iconType", "possible-typeof", "string");
			check("onMouseHold", "possible-typeof", "function");
			check("_beforeDrop", "possible-typeof", "function");
		}

		makeStyle(when) {
			return {
				width: "100%",
				position: "relative",

				'*': {
					boxSizing: "border-box",
					color: PRESET("softWhite")
				},

				Bar: {
					width: "100%",
					height: "40px",
					backgroundColor: PRESET("softNavy"),

					padding: "0px 7px",
					boxSizing: "border-box",

					display: "flex",
					justifyContent: "space-around",
					alignItems: "center",

					position: "relative",
					userSelect: "none"
				},

				IconDiv: {
					width: "30px",
					height: "30px",
					margin: "0px 12px 0px 4px"
				},

				Spacer: {
					flex: 1
				},

				BottomBar: {
					width: "100%",
					height: "6px",
					backgroundColor: PRESET("softNavy"),

					animation: "BottomBar_undropShiftAnimation 0.33s",
					animationFillMode: "forwards",

					[when("shifted")]: {
						animationName: "BottomBar_dropShiftAnimation"
					}
				}
			};
		}

		render() {
			return React.createElement(
				"div",
				{ ref: this._ref, className: "DropdownBar" },
				React.createElement(
					Holdable,
					{ onHold: () => this.props.onMouseHold() },
					React.createElement(
						"div",
						{ className: "Bar" },
						React.createElement(
							"div",
							{ className: "IconDiv" },
							React.createElement(SVGIcon, { type: this.props.iconType || "blank" })
						),
						this.props.title,
						React.createElement("div", { className: "Spacer" }),
						React.createElement(DropdownButton, { onClick: () => this.toggleDrop(), dropped: this.state.dropped })
					)
				),
				React.createElement(
					DropdownContent,
					{ dropped: this.state.dropped },
					this.props.children
				),
				React.createElement("div", {
					className: \`BottomBar \${this.state.dropped ? "shifted" : ''}\`,
					style: {
						animationDuration: this.state.barAnimating ? null : "0s",
						height: this.state.dropped || this.state.barAnimating ? null : "0px"
					},
					onAnimationEnd: event => this.setState({ barAnimating: false })
				})
			);
		}

		async toggleDrop() {
			this.setState((state, props) => {
				return { dropped: !state.dropped, barAnimating: true };
			});
			this.props._beforeDrop(this._ref.current, this.state.dropped); // being outside the above setState() allows React to batch/sync animation group setState() calls
		}
	}

	class DropdownButton extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				animating: null, // type: true/false after mounting
				lastDropped: null
			};

			const check = this.addCheckForProp;
			check("onClick", "typeof", "function");
			check("dropped", "typeof", "boolean");
		}

		makeStyle(when) {
			return {
				width: "30px",
				height: "30px",

				stroke: PRESET("softWhite"),
				strokeWidth: "3px",

				animation: "DropdownButton_undropAnimation 0.3s forwards",
				animationTimingFunction: "ease-out",

				[when("dropped")]: {
					animationName: "DropdownButton_dropAnimation",
					animationTimingFunction: "ease-out"
				},

				"@keyframes DropdownButton_undropAnimation": {
					from: {
						transform: "rotateX(180deg)"
					}
				},
				"@keyframes DropdownButton_dropAnimation": {
					to: {
						transform: "rotateX(180deg)"
					}
				}
			};
		}

		static getDerivedStateFromProps(props, state) {
			if (state.lastDropped === null) {
				state.lastDropped = props.dropped;
			} else if (props.dropped !== state.lastDropped) {
				state.animating = true;
				state.lastDropped = props.dropped;
			}
			return state;
		}

		render() {
			const left = 10;
			const mid = 20;
			const right = 30;
			const top = 14;
			const btm = 25;

			// lines must go past the "point" of the arrow (by 1/2 the stroke width)
			// using pyth-theo, we get it down to this math:
			// offset = (((w / 2) ** 2) / 2) ** (1 / 2)
			// (condensed a bit)
			// offset = w * 2 ** (1 / 2) / 4
			const offset = 1.0606601717; // for w = 3px
			return React.createElement(
				"svg",
				{
					className: \`DropdownButton \${this.props.dropped ? "dropped" : ""}\`,
					style: {
						animationDuration: this.state.animating ? null : "0s"
					},
					viewBox: "0 0 40 40",
					onClick: this.props.onClick,
					onAnimationEnd: event => this.setState({ animating: false })
				},
				React.createElement("line", { x1: left, y1: btm, x2: mid + offset, y2: top + offset }),
				React.createElement("line", { x1: right, y1: btm, x2: mid - offset, y2: top + offset })
			);
		}
	}

	class DropdownContent extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				lastDropped: null,
				animating: false
			};

			const check = this.addCheckForProp;
			check("dropped", "typeof", "boolean");
		}

		makeStyle(when) {
			return {
				maxHeight: "300px",
				width: "86%",

				padding: "0px",
				marginLeft: "8px",
				backgroundColor: PRESET("clear"),

				animation: "DropdownContent_undropAnimation 0.33s forwards",

				[when("dropped")]: {
					animationName: "DropdownContent_dropAnimation"
				},

				"@keyframes DropdownContent_dropAnimation": {
					from: {
						opacity: 0,
						transform: "translateY(-50%) scaleY(0)"
					}
				},
				"@keyframes DropdownContent_undropAnimation": {
					to: {
						opacity: 0,
						transform: "translateY(-50%) scaleY(0)"
					}
				},

				Container: {
					width: "100%",
					maxHeight: "300px",
					overflowY: "scroll",

					'>*': {
						margin: "12px 0px"
					}
				},

				TopGradient: {
					position: "absolute",
					top: "0px",
					width: "100%",

					borderBottom: "12px solid",
					borderImage: \`linear-gradient(
					to bottom,
					\${PRESET("deepNavy", { alpha: 0.7 })},
					\${PRESET("deepNavy", { alpha: 0.55 })},
					\${PRESET("deepNavy", { alpha: 0.3 })},
					\${PRESET("deepNavy", { alpha: 0.15 })},
					\${PRESET("clear")}
				) 12\`,
					opacity: 0.8
				},

				BottomGradient: {
					position: "absolute",
					bottom: "0px",
					width: "100%",

					borderTop: "10px solid",
					borderImage: \`linear-gradient(
					to top,
					\${PRESET("deepNavy", { alpha: 0.65 })},
					\${PRESET("deepNavy", { alpha: 0.35 })},
					\${PRESET("deepNavy", { alpha: 0.15 })},
					\${PRESET("clear")}
				) 10\`
				}
			};
		}

		static getDerivedStateFromProps(props, state) {
			if (state.lastDropped === null) {
				state.lastDropped = props.dropped;
			} else if (state.lastDropped !== props.dropped) {
				state.animating = true;
				state.lastDropped = props.dropped;
			}
		}

		render() {
			return React.createElement(
				"div",
				{
					className: \`DropdownContent \${this.props.dropped ? "dropped" : ''}\`,
					style: {
						animationDuration: this.state.animating ? null : "0s",
						height: this.props.dropped || this.state.animating ? null : "0px"
					},
					onAnimationEnd: () => this.setState({ animating: false })
				},
				React.createElement(
					"div",
					{ className: "Container" },
					this.props.children
				),
				React.createElement("div", { className: "TopGradient" }),
				React.createElement("div", { className: "BottomGradient" })
			);
		}
	}

	if (false) {
		class TempContainer extends ReactStyles.Component {
			constructor(props) {
				super(props);

				this._dropdownRef = React.createRef();
			}

			makeStyle() {
				return React.createElement(
					"style",
					null,
					\`
				.TempContainer {
					width: 100vw;
					height: 100vh;
					background-color: \${PRESET("deepNavy")};
					position: absolute;
					top: 0px;
					left: 0px;
				}
				
				.TempContainer h1 {
					color: green;
					margin: 3px;
					font-size: 25px;
				}
				
				.DropdownBar {
					margin: 5px;
				}
				
				.TransMe {
					background-color: red;
					width: 100px;
					height: 100px;
					animation: TransMeAnim 0.5s alternate infinite;
				}
				
				@keyframes TransMeAnim {
					from {
						transform: translate(-50px, 0px);
					}
					to {
						transform: translate(50px, 20px);
					}
				}
			\`
				);
			}

			render() {
				const transRef = React.createRef();
				return React.createElement(
					"div",
					null,
					React.createElement(
						DropdownAnimationGroup,
						null,
						React.createElement(
							"div",
							null,
							React.createElement(
								"h1",
								null,
								"TOP THINGY"
							),
							React.createElement(
								DropdownBar,
								{
									title: "testtitle1",
									iconType: "magGlass"
								},
								React.createElement("div", { ref: transRef, className: "TransMe" }),
								React.createElement(
									Draggable,
									null,
									React.createElement(
										NoteBox,
										{ title: "Test Title 1" },
										["test line 1", "test line 2 is a much longer line because it needs to test what happens when an important test because it helps make  text and isnt really that useful to read it helps fill the text full ",
										//"test line 2 is a much longer line because it needs to test what happens when text is wrapped around to the next line, which is an important test because it helps make sure the styles work for all cases, even if most of this text is just filler text and isnt really that useful to read it helps fill the text full of text so you can see how well the text works over multiple lines", 
										"test\\nline\\n3"]
									)
								),
								React.createElement(
									Draggable,
									null,
									React.createElement(
										NoteBox,
										{ title: "Test Title 2 and a bit longer" },
										["test line 1"]
									)
								)
							),
							React.createElement(
								DropdownBar,
								{
									ref: this._dropdownRef,
									title: "testtitle0",
									iconType: "magGlass",
									onMouseHold: () => alert("hold")
								},
								React.createElement(
									Draggable,
									null,
									React.createElement(
										NoteBox,
										{ title: "Test Title 0" },
										[]
									)
								)
							),
							React.createElement(
								"h1",
								null,
								"SMOOTHLY (SIBLING)"
							)
						),
						React.createElement(
							"div",
							{ style: { backgroundColor: "blue" } },
							React.createElement(
								"h1",
								null,
								"SMOOTHLY (OUTSIDE)"
							)
						)
					),
					React.createElement(
						"h1",
						null,
						"TELEPORTY"
					)
				);
			}
		}

		ReactDOM.render(React.createElement(TempContainer, null), root);
	}

	class NoteBox extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this._titleRef = React.createRef();
			this._contentRef = React.createRef();

			const check = this.addCheckForProp;
			check("title", "possible-typeof", "string");
			check("content", "possible-typeof", "string");
			check("preventOverwrite", "possible-typeof", "boolean");
			check("forceBlur", "possible-typeof", "boolean");
			check("forceDetectChange", "possible-typeof", "boolean");
			check("onTitleChange", "possible-typeof", "function");
			check("onContentChange", "possible-typeof", "function");
		}

		makeStyle(when) {
			return {
				minHeight: "10px", // so empty notes can be seen (mostly for debugging)

				width: "100%",
				height: "100%",
				backgroundColor: PRESET("softNavy", { alpha: 0.73 }),

				display: "flex",
				flexFlow: "column nowrap",
				alignItems: "stretch",
				justifyContent: "center",

				'>*': {
					margin: "12px 10px",
					padding: "0px",
					overflow: "hidden",

					color: PRESET("softWhite"),
					backgroundColor: PRESET("clear"),
					fontFamily: "sans-serif",

					border: "none"
				},

				Title: {
					maxWidth: "90%",

					textAlign: "center",
					alignSelf: "center",

					padding: "0px 6px",
					fontSize: "calc(15px + 0.25em)",
					lineHeight: "calc(1.2 * (15px + 0.25em))",

					borderBottom: \`2px solid \${PRESET("ghostNavy", { alpha: 0.75 })}\`
				},

				Content: {
					fontSize: "1em",
					lineHeight: "1.3em"
				}
			};
		}

		render() {
			if (this.props.forceBlur) {
				const active = document.activeElement;
				const title = this._titleRef.current;
				const content = this._contentRef.current;
				if (title === active || content === active) {
					const parent = active.parentNode;
					const textarea = document.createElement("textarea");
					parent.appendChild(textarea);
					textarea.focus();
					parent.removeChild(textarea);
				}
			}

			if (this.props.forceDetectChange) {
				const title = this._titleRef.current;
				if (title) {
					this._detectIfTitleChanged(title.value);
				}
				const content = this._contentRef.current;
				if (content) {
					this._detectIfContentChanged(content.value);
				}
			}

			return React.createElement(
				"div",
				null,
				this.renderTitle(),
				this.renderContent()
			);
		}

		renderTitle() {
			let title = this.props.title;
			if (Array.isArray(title)) {
				title = title.join('\\n');
			}
			this._lastTitle = title;

			if (!title) {
				return null;
			}

			return React.createElement("textarea", {
				ref: this._titleRef,
				className: "Title",

				rows: "1",
				cols: "1",
				wrap: "off",

				onBlur: event => this._detectIfTitleChanged(event.target.value),
				onInput: event => this._updateDims(event.target, "title"),
				defaultValue: title
			});
		}

		renderContent() {
			let content = this.props.children || this.props.content;
			if (Array.isArray(content)) {
				content = content.join('\\n');
			}
			this._lastContent = content;

			if (!content) {
				return null;
			}

			return React.createElement("textarea", {
				ref: this._contentRef,
				className: "Content",

				rows: "1",
				cols: "1",

				onBlur: event => this._detectIfContentChanged(event.target.value),
				onInput: event => this._updateDims(event.target, "content"),
				defaultValue: content
			});
		}

		componentDidMount() {
			const title = this._titleRef.current;
			if (title) {
				title.style.height = title.scrollHeight + "px";
				title.style.width = title.scrollWidth + "px";
			}

			const content = this._contentRef.current;
			if (content) {
				content.style.height = content.scrollHeight + "px";
				content.style.width = content.scrollWidth + "px";
			}
		}

		componentDidUpdate() {
			if (!this.props.preventOverwrite) {
				const title = this._titleRef.current;
				if (title) {
					title.value = this._lastTitle;
					this._updateDims(title);
				}

				const content = this._contentRef.current;
				if (content) {
					content.value = this._lastContent;
					this._updateDims(content);
				}
			}
		}

		// NOTE: these are used during onBlur() because onChange() isnt working
		_detectIfPropChanged(str, compStr, onChangeName) {
			if (str !== compStr) {
				str = str.replaceAll('<br>', '\\n');
				if (str[0] === '\\n') {
					str = str.slice(1);
				}
				if (str[str.length - 1] === '\\n') {
					str = str.slice(0, str.length - 1);
				}

				try {
					this.props[onChangeName](str);
				} catch (_) {
					// keeps render() from crashing if undefined
				}
			}
		}

		_detectIfTitleChanged(titleStr) {
			this._detectIfPropChanged(titleStr, this._lastTitle, "onTitleChange");
		}
		_detectIfContentChanged(contentStr) {
			this._detectIfPropChanged(contentStr, this._lastContent, "onContentChange");
		}

		_updateDims(elem, name) {
			elem.style.height = "auto"; // allows shrinking
			elem.style.height = elem.scrollHeight + "px";

			if (name === "title") {
				elem.wrap = "off"; // temporary, to see if it is still maxed
			}

			elem.style.width = "auto";
			elem.style.width = elem.scrollWidth + "px";

			if (name === "title") {
				const max = elem.parentNode.offsetWidth * 0.9 - 5; // gives a little wiggle room from the max
				const isMaxed = elem.offsetWidth > max;
				if (isMaxed) {
					elem.wrap = "on";
					elem.style.width = max;
				}
			}
		}
	}

	if (false) {
		class Container extends ReactStyles.Component {
			render() {
				return React.createElement(
					"div",
					null,
					React.createElement(
						NoteBox,
						{ title: !"Test title" || null, onTitleChange: t => alert(t), onContentChange: c => alert(c) },
						["test line 1", "test line 2 is a much lo] nger line because it needs to test what happens when text is wrapped around to the next line, which is an important test because it helps make sure the styles work for all cases, even if most of this text is just filler text and isnt really that useful to read it helps fill the text full of text so you can see how well the text works over multiple lines",
						//"test line 2 is a much longer line because it needs to test what happens when text is wrapped around to the next line, which is an important test because it helps make sure the styles work for all cases, even if most of this text is just filler text and isnt really that useful to read it helps fill the text full of text so you can see how well the text works over multiple lines", 
						"test\\nline\\n3"].join('\\n\\n') || null
					)
				);
			}
		}

		ReactDOM.render([React.createElement(Container, null), React.createElement("div", { style: { display: "none", width: "150px", height: "150px", backgroundColor: "red", position: "absolute", top: "0px" } })], root);
	}

	// NOTE: this animation group applies animations to its children; the
	// SlidingBars can be tracked at any level under this group (unlike the
	// dropdown bars/animation groups)
	class SlidingAnimationGroup extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				shrunkBy: -1 // -1 means not shrunk, otherwise idx of child which caused it
			};

			this._groupRef = React.createRef();
		}

		makeStyle(when) {
			this._lastShrunk = this.state.shrunkBy !== -1; // prevents initial animation
			return {
				Bars: {
					pointerEvents: () => {
						const shrunk = this.state.shrunkBy !== -1;
						this._groupRef.current.style["pointer-events"] = shrunk ? "none" : null;
						return "all";
					},

					animation: () => {
						const shrunk = this.state.shrunkBy !== -1;
						this._groupRef.current.style["animation-direction"] = shrunk ? null : "reverse";
						if (shrunk !== this._lastShrunk) {
							this._groupRef.current.style["animation-duration"] = "0.43s";
							ReactStyles.rerunAnimationOn(this._groupRef.current, "Bars");
						}
						return "SlidingAnimationGroupShrink 0s forwards";
					},
					"@keyframes SlidingAnimationGroupShrink": {
						from: {
							opacity: 1,
							transform: "scale(1)"
						},
						80: {
							opacity: 0,
							transform: "scale(0.67)"
						},
						to: {
							opacity: 0,
							transform: "scale(0.67)"
						}
					}
				}
			};
		}

		render() {
			const { children, contents } = this._wrapChildren();
			return React.createElement(
				"div",
				null,
				React.createElement(
					"div",
					{ className: "Bars", ref: this._groupRef },
					children
				),
				React.createElement(
					"div",
					{ className: "Contents" },
					contents
				)
			);
		}

		componentDidUpdateStyle() {
			this._lastShrunk = this.state.shrunkBy !== -1;
		}

		_wrapChildren() {
			let children = this.props.children;
			if (!(children instanceof Array)) {
				children = [children];
			}

			const contents = [];
			this._trackSlidingBars(children, contents);
			return { children, contents };
		}

		_trackSlidingBars(children, trackedContents) {
			let trackCount = 0;
			for (let idx = 0; idx < children.length; idx++) {
				const child = children[idx];
				const shouldTrack = child && child.type === SlidingBar;
				const isAnimationGroup = child && child.type === DropdownAnimationGroup;
				if (shouldTrack) {
					const trackIdx = trackCount++;
					const contentRef = React.createRef();
					child.props._beforeSlide = () => {
						this._whenChildReqSlide(trackIdx, contentRef);
					};
					child.props._tracked = true;
					trackedContents.push(React.createElement(
						SlidingContent,
						{ ref: contentRef, visible: this.state.shrunkBy === idx, _tracked: this.props._tracked },
						child.props.children
					));
					this._bindToBackButtons(child.props.children, contentRef);
				} else if (isAnimationGroup) {
					this._trackSlidingBars(child.props.children, trackedContents);
				}
			}
		}

		_whenChildReqSlide(trackIdx, contentRef) {
			this.setState({ shrunkBy: trackIdx });
			contentRef.current.toggleSlide();
		}

		_bindToBackButtons(children, contentRef) {
			if (!Array.isArray(children)) {
				children = [children];
			}
			for (let i = 0; i < children.length; i++) {
				const child = children[i];
				if (child) {
					if (child.type === SlidingBackButton) {
						child.props.onClick = () => {
							this._whenChildReqSlide(-1, contentRef);
						};
					}
					if (child.props && child.props.children) {
						this._bindToBackButtons(child.props.children);
					}
				}
			}
		}
	}

	class SlidingBar extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				didSlide: false
			};

			const check = this.addCheckForProp;
			check("title", "possible-typeof", "string");
			check("iconType", "possible-typeof", "string");
			check("onMouseHold", "possible-typeof", "function");

			check("_beforeSlide", "possible-typeof", "function");
			check("_tracked", "possible-typeof", "boolean");
		}

		makeStyle(when) {
			return {
				width: "100%",
				position: "relative",

				Bar: {
					width: "100%",
					height: "50px",
					color: PRESET("softWhite"),
					backgroundColor: PRESET("softNavy"),

					padding: "0px 7px",
					boxSizing: "border-box",

					display: "flex",
					justifyContent: "space-around",
					alignItems: "center",

					position: "relative",
					userSelect: "none"
				},

				IconDiv: {
					width: "35px",
					height: "35px",
					margin: "0px 12px 0px 4px"
				},

				Spacer: {
					flex: 1
				}
			};
		}

		render() {
			return React.createElement(
				"div",
				{ className: "SlidingBar" },
				React.createElement(
					"div",
					{
						className: "Bar",
						onTouchStart: event => this._startMouseHold(event),
						onTouchEnd: event => this._cancelMouseHold(event),
						onTouchMove: event => this._cancelMouseHold(event)
					},
					React.createElement(
						"div",
						{ className: "IconDiv" },
						React.createElement(SVGIcon, { type: this.props.iconType || "blank" })
					),
					this.props.title,
					React.createElement("div", { className: "Spacer" }),
					React.createElement(SliderButton, { onClick: () => this.toggleSlide() })
				)
			);
		}

		componentDidMount() {
			window.requestAnimationFrame(() => this._lastDidSlide = this.state.dropped); // update after makeStyle()
		}

		componentDidUpdate() {
			window.requestAnimationFrame(() => this._lastDidSlide = this.state.dropped); // update after makeStyle()
		}

		async toggleSlide() {
			this.setState((state, props) => {
				return { didSlide: !state.didSlide };
			});
			this.props._beforeSlide(this.state.didSlide); // being outside the above setState() allows React to batch other setState calls onDrop() makes
		}

		_startMouseHold(event) {
			this._holdTimeout = setTimeout(() => this.props.onMouseHold(), 600);
			this._lastTouch = null;
		}
		_cancelMouseHold(event) {
			// NOTE: sometimes touchMove is activated when it is still, so this detects if there was actually a move
			if (event.touches[0]) {
				const { clientX, clientY } = event.touches[0];
				if (!this._lastTouch) {
					this._lastTouch = { x: clientX, y: clientY };
					return;
				} else if (this._lastTouch.x === clientX && this._lastTouch.y === clientY) {
					return;
				}
			}
			clearTimeout(this._holdTimeout);
		}
	}

	class SliderButton extends ReactStyles.Component {
		constructor(props) {
			super(props);

			const check = this.addCheckForProp;
			check("onClick", "typeof", "function");
		}

		makeStyle(when) {
			return {
				width: "30px",
				height: "30px",

				stroke: PRESET("softWhite"),
				strokeWidth: "3px"
			};
		}

		render() {
			const left = 15;
			const right = 25;
			const top = 10;
			const mid = 20;
			const btm = 30;

			// lines must go past the "point" of the arrow (by 1/2 the stroke width)
			// using pyth-theo, we get it down to this math:
			// offset = (((w / 2) ** 2) / 2) ** (1 / 2)
			// (condensed a bit)
			// offset = w * 2 ** (1 / 2) / 4
			const offset = 1.0606601717; // for w = 3px
			return React.createElement(
				"svg",
				{ onClick: this.props.onClick, viewBox: "0 0 40 40", onAnimationEnd: event => this._selfElem = event.target },
				React.createElement("line", { x1: left, y1: top, x2: right + offset, y2: mid + offset }),
				React.createElement("line", { x1: left, y1: btm, x2: right + offset, y2: mid - offset })
			);
		}
	}

	class SlidingContent extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				visible: false
			};

			const check = this.addCheckForProp;
			check("visible", "possible-typeof", "boolean");

			check("_tracked", "possible-typeof", "boolean");
		}

		makeStyle(when) {
			return {
				position: "absolute",
				top: "0px",
				left: "0px",

				opacity: () => {
					if (this._selfElem) {
						this._selfElem.style.opacity = 1;
					}
					return 0;
				},
				pointerEvents: () => {
					if (this._selfElem) {
						this._selfElem.style["pointer-events"] = this.state.visible ? "all" : null;
					}
					return "none";
				},

				animation: () => {
					if (this._selfElem) {
						this._selfElem.style["animation-duration"] = "0.45s";
						this._selfElem.style["animation-direction"] = this.state.visible ? null : "reverse";
						if (this.state.visible !== this._lastVisible) {
							ReactStyles.rerunAnimationOn(this._selfElem, this.componentName);
						}
					}
					return "SlidingContentSlideAnimation 0s forwards";
				},
				"@keyframes SlidingContentSlideAnimation": {
					from: {
						opacity: 0,
						transform: "translateX(130px)"
					},
					40: {
						opacity: 0,
						transform: "translateX(130px)"
					}
				}
			};
		}

		render() {
			return React.createElement(
				"div",
				{ className: \`SlidingContent \${this.props._tracked ? "tracked" : ""}\`, onAnimationEnd: event => {
						if (event.target.classList.contains("SlidingContent")) {
							this._selfElem = event.target;
						}
					} },
				this.props.children
			);
		}

		componentDidUpdateStyle() {
			this._updateLastProps();
		}

		toggleSlide() {
			this.setState((state, props) => {
				return { visible: !state.visible };
			});
		}

		_updateLastProps() {
			this._lastVisible = this.state.visible;
		}
	}

	class SlidingBackButton extends ReactStyles.Component {
		constructor(props) {
			super(props);

			const check = this.addCheckForProp;
			check("onClick", "possible-typeof", "function");
		}

		render() {
			return React.createElement(
				"button",
				{ onClick: () => this.props.onClick() },
				this.props.children
			);
		}
	}

	if (false) {
		class TempContainer extends ReactStyles.Component {
			constructor(props) {
				super(props);

				this._dropdownRef = React.createRef();
			}

			makeStyle() {
				return React.createElement(
					"style",
					null,
					\`
				.TempContainer {
					width: 100vw;
					height: 100vh;
					background-color: \${PRESET("deepNavy")};
					position: absolute;
					top: 0px;
					left: 0px;
				}
				
				.TempContainer h1 {
					color: green;
				}
				
				.SlidingAnimationGroup {
					position: absolute;
					top: 30px;
					left: 10px;
				}
				
				.TransMe {
					background-color: red;
					width: 100px;
					height: 100px;
					animation: TransMeAnim 0.5s alternate infinite;
				}
				
				@keyframes TransMeAnim {
					from {
						transform: translate(-50px, 0px);
					}
					to {
						transform: translate(50px, 20px);
					}
				}
			\`
				);
			}

			render() {
				const transRef = React.createRef();
				return React.createElement(
					"div",
					null,
					React.createElement(
						"h1",
						null,
						"Outside child"
					),
					React.createElement(
						SlidingAnimationGroup,
						null,
						React.createElement(
							DropdownAnimationGroup,
							null,
							React.createElement(
								"h1",
								null,
								"Inside child"
							),
							React.createElement(
								SlidingBar,
								{ title: "Test Bar Numbero UNO", onMouseHold: () => alert("held!") },
								React.createElement(
									"h1",
									null,
									"Inside Sliding Bar"
								),
								React.createElement(
									SlidingBackButton,
									null,
									"BACK"
								)
							),
							React.createElement(
								DropdownBar,
								{ title: "Test dropdown" },
								React.createElement(
									"h1",
									null,
									"Inside Dropdown"
								)
							),
							React.createElement(
								SlidingBar,
								{ title: "Test Bar Numbero DOS", onMouseHold: () => alert("held!") },
								React.createElement(
									SlidingBackButton,
									null,
									"BACK"
								),
								React.createElement(
									"h1",
									null,
									"Inside Sliding Bar AGAIN"
								)
							)
						)
					)
				);
			}
		}

		ReactDOM.render(React.createElement(TempContainer, null), root);
	}

	!async function () {
		/* STRUCTURE */
		const ANIMATION_TIME = 0.4;
		let generateAvailable = false;
		const popupRoot = React.createRef();
		let submitElem; // ALWAYS the original element
		const submitRefCurr = React.createRef(); // updated when "Enter" can be used
		let finalSubmit; // will be set to the final submission object later

		let lastRender = null;
		function renderPageController(prevElems, elems, elemsKey, time = 0, direction = "") {
			const renderMe = React.createElement(
				"div",
				{ className: "POPUP_promptDeepLink_pageManager " + direction },
				React.createElement(
					"style",
					null,
					\`
				.POPUP_promptDeepLink_pageManager {
					width: 200%;
					height: 100%;
					
					display: flex;
					flex-flow: row nowrap;
					justify-content: center;
					align-items: center;
					
					position: absolute;
					top: 0px;
					left: 0px;
					
				}
				.POPUP_promptDeepLink_pageManager.normal {
					animation: POPUP_pageScroll_normal \${time}s forwards;
					animation-timing-function: ease-out;
				}
				.POPUP_promptDeepLink_pageManager.reverse {
					animation: POPUP_pageScroll_reverse \${time}s forwards;
					animation-timing-function: ease-out;
				}
				
				@keyframes POPUP_pageScroll_normal {
					to {
						transform: translateX(-50%);
					}
				}
				@keyframes POPUP_pageScroll_reverse {
					from {
						transform: translateX(-50%);
					}
				}
				
				.POPUP_promptDeepLink_page {
					width: 100%;
					height: 100%;
					overflow-y: scroll;
				}
				/* putting flex on page directly causes scrolling issues */
				.POPUP_promptDeepLink_centerizer {
					width: 100%;
					display: flex;
					flex-flow: column nowrap;
					align-items: center;
				}
				
				.POPUP_promptDeepLink_enterButton {
					width: 100%;
					height: 100%;
					position: relative;
				}
				
				.POPUP_promptDeepLink_enterButtonBlock {
					width: calc(100% + 10px);
					height: calc(100% + 10px);
					
					position: absolute;
					top: -5px;
					left: -5px;
					padding-top: 5px;
					
					display: \${!generateAvailable ? "block" : "none"};
					background-color: \${PRESET("deepNavy", { alpha: 0.7 })};
				}
				
				.POPUP_promptDeepLink_backButton {
					width: 100%;
					height: 100%;
					position: relative;
				}
				
				.POPUP_promptDeepLink_backButtonBlock {
					width: calc(100% + 10px);
					height: calc(100% + 10px);
					
					position: absolute;
					top: -5px;
					left: -5px;
					padding-top: 5px;
					
					display: \${pages.length === 1 ? "block" : "none"};
					background-color: \${PRESET("deepNavy", { alpha: 0.7 })};
				}
			\`
				),
				React.createElement(
					"div",
					{ className: "POPUP_promptDeepLink_page", key: elemsKey - 1 },
					React.createElement(
						"div",
						{ className: "POPUP_promptDeepLink_centerizer", key: "SAME" },
						prevElems
					)
				),
				React.createElement(
					"div",
					{ className: "POPUP_promptDeepLink_page", key: elemsKey },
					React.createElement(
						"div",
						{ className: "POPUP_promptDeepLink_centerizer" },
						elems
					)
				)
			);
			lastRender = { prevElems, elems, elemsKey, time, direction };
			ReactDOM.render(renderMe, popupRoot.current);
		}
		function refreshPageController() {
			const { prevElems, elems, elemsKey, time, direction } = lastRender;
			renderPageController(prevElems, elems, elemsKey, time, direction);
		}

		const pages = [];
		function pageForward(elems, animate = true) {
			const key = pages.length;
			const prevElems = pages[pages.length - 1];
			pages.push(elems);

			if (animate) {
				const time = prevElems ? ANIMATION_TIME : 0;
				renderPageController(prevElems, elems, key, time, "normal");
				setTimeout(() => renderPageController(elems, null, key + 1), time * 1000 + 100);
			} else {
				renderPageController(elems, null, pages.length);
			}
		}

		function pageBackward() {
			generateAvailable = false;
			submitRefCurr.current = null;

			const elems = pages.pop();
			const key = pages.length;
			const prevElems = pages[pages.length - 1];

			const time = ANIMATION_TIME;
			renderPageController(prevElems, elems, key, time, "reverse");
			setTimeout(() => renderPageController(prevElems, null, key), time * 1000 + 100);
		}

		POPUP.createCustom(content => {
			content.push(React.createElement(
				"h2",
				null,
				"Generate Link"
			));

			content.push(React.createElement(
				"div",
				{ ref: popupRoot, style: {
						width: "100%",
						height: "250px",
						position: "relative",
						overflow: "hidden",
						display: "flex",
						flexFlow: "column nowrap",
						justifyContent: "center",
						alignItems: "center"
					} },
				renderHome()
			));

			content.push(React.createElement(
				PopupButtonList,
				null,
				React.createElement(
					PopupButton,
					{ onClick: () => pageBackward() },
					React.createElement(
						"div",
						{ className: "POPUP_promptDeepLink_backButton" },
						React.createElement("div", {
							className: "POPUP_promptDeepLink_backButtonBlock",
							onClick: event => event.stopPropagation()
						}),
						"Back"
					)
				),
				React.createElement(PopupSpacer, null),
				React.createElement(
					PopupButton,
					{ ref: submitRefCurr, onClick: () => generateAndReturnLink(finalSubmit) },
					React.createElement(
						"div",
						{ className: "POPUP_promptDeepLink_enterButton" },
						React.createElement("div", {
							className: "POPUP_promptDeepLink_enterButtonBlock",
							onClick: event => event.stopPropagation()
						}),
						"Generate"
					)
				)
			));
			return submitRefCurr;
		}, "promptDeepLink", false);

		/* PAGES */
		function renderHome() {
			// NOTE: elem is ALWAYS elem; ref.current is updated when [Enter] key can be used
			submitElem = submitRefCurr.current;
			submitRefCurr.current = null;

			function button(name, color, alpha) {
				const style = {
					fontWeight: "700",
					fontSize: "20px",

					padding: "5px 0px",
					width: "80%",
					border: "none",

					backgroundColor: PRESET(color, { alpha })
				};
				return React.createElement(
					"button",
					{
						onClick: () => {
							if (name === "Custom Search") {
								renderSearch();
							} else {
								renderBooks(name);
							}
						},
						style: style
					},
					name
				);
			}

			const colorful = [["softRed", 0.3], ["dullYellow", 0.5], ["strongBlue", 0.3], ["softNavy", 1.0], ["deepYellow", 0.4], ["softGrey", 0.7]];
			const monotone = [["softNavy", 1], ["ghostNavy", 0.7]];

			const selected = monotone;
			const names = ["Old Testament", "New Testament", "Book of Mormon", "Doctrine & Covenants", "Pearl of Great Price"];
			const content = [];
			for (let i = 0; i < names.length; i++) {
				const name = names[i];
				const [color, alpha] = selected[i % selected.length];
				content.push(button(name, color, alpha));
			}
			setTimeout(() => pageForward(content, false));
			return content; // kinda special, since it is the first to be run
		}

		function renderBooks(name) {
			const worksMap = {
				"Old Testament": "OT",
				"New Testament": "NT",
				"Book of Mormon": "BOM",
				"Doctrine & Covenants": "DC",
				"Pearl of Great Price": "PGP"
			};
			const work = worksMap[name];

			function button(name, rawName, color, alpha) {
				const style = {
					fontWeight: "550",
					fontSize: "14px",

					padding: "4px 0px",
					width: "120px",
					border: "none",

					backgroundColor: PRESET(color, { alpha })
				};
				return React.createElement(
					"button",
					{
						onClick: () => {
							if (work === "DC") {
								renderGetVerses(work, rawName, null);
							} else {
								renderChapters(work, rawName);
							}
						},
						style: style
					},
					name
				);
			}

			const colors = [["softNavy", 1], ["ghostNavy", 0.7], ["softNavy", 1], ["softNavy", 1], ["ghostNavy", 0.7], ["softNavy", 1], ["softNavy", 1], ["softNavy", 1]];
			const content = [];
			let row = [];
			let i = 0;

			if (work === "DC") {
				for (const bookName in SCRIPTURES.all[work]) {
					const [color, alpha] = colors[i % colors.length];
					row.push(button("Section " + (parseInt(bookName) + 1), bookName, color, alpha));
					i++;

					if (i % 2 === 0) {
						content.push(React.createElement(
							"div",
							null,
							row
						));
						row = [];
					}
				}
			} else {
				for (const bookName in SCRIPTURES.all[work]) {
					const [color, alpha] = colors[i % colors.length];
					row.push(button(SCRIPTURES.prettyName(bookName), bookName, color, alpha));
					i++;

					if (i % 2 === 0) {
						content.push(React.createElement(
							"div",
							null,
							row
						));
						row = [];
					}
				}
			}

			while (row.length % 2 !== 0) {
				row.push(button("", "", "darkBlack", 0));
			}
			if (row.length > 0) {
				content.push(React.createElement(
					"div",
					null,
					row
				));
			}
			pageForward(content);
		}

		function renderChapters(work, book) {
			function button(number, color, alpha) {
				const style = {
					fontWeight: "700",
					fontSize: "18px",

					padding: "4px 0px",
					margin: "8px",
					width: "35px",
					border: "none",

					backgroundColor: PRESET(color, { alpha })
				};
				return React.createElement(
					"button",
					{
						onClick: () => {
							renderGetVerses(work, book, number - 1);
						},
						style: style
					},
					number
				);
			}

			const colors = [["softNavy", 1], ["softNavy", 1], ["ghostNavy", 0.7], ["softNavy", 1]];
			const content = [];
			let row = [];
			let i = 0;

			for (const chapter in SCRIPTURES.all[work][book]) {
				const [color, alpha] = colors[i % colors.length];
				row.push(button(parseInt(chapter) + 1, color, alpha));
				i++;

				if (i % 5 === 0) {
					content.push(React.createElement(
						"div",
						null,
						row
					));
					row = [];
				}
			}

			if (i === 1) {
				renderGetVerses(work, book, 0);
			} else {
				while (row.length % 5 !== 0) {
					row.push(button("", "darkBlack", 0));
				}
				if (row.length > 0) {
					content.push(React.createElement(
						"div",
						null,
						row
					));
				}
				pageForward(content);
			}
		}

		function renderGetVerses(work, book, chapter) {
			const spacer = React.createElement("div", { style: { margin: "5px" } });
			let bookTitle;
			if (work === "DC") {
				bookTitle = SCRIPTURES.prettyName(work, book);
			} else if (SCRIPTURES.all[work][book].length === 1) {
				bookTitle = SCRIPTURES.prettyName(book);
			} else {
				bookTitle = SCRIPTURES.prettyName(book, chapter);
			}

			const content = [];
			content.push(spacer);
			content.push(spacer);
			content.push(React.createElement(
				"h4",
				null,
				"Enter verses for"
			));
			content.push(React.createElement(
				"h2",
				null,
				bookTitle
			));
			content.push(spacer);
			content.push(React.createElement(
				"h4",
				{ style: { marginBottom: "0px", fontWeight: 500 } },
				"Enter a number, range, or leave"
			));
			content.push(React.createElement(
				"h4",
				{ style: { marginTop: "0px", fontWeight: 500 } },
				"blank to use the whole chapter"
			));
			content.push(React.createElement(
				"h5",
				{ style: { marginTop: "0px", fontWeight: 380 } },
				"(range can use a dash ' - ' or a space ' ",
				'\\0',
				" ')"
			));
			content.push(spacer);
			content.push(spacer);

			generateAvailable = true;
			finalSubmit = validSubmitRange(null, work, book, chapter);

			const range = \`1-\${finalSubmit.end}\`;
			content.push(React.createElement(
				"div",
				{ style: { width: "25%" } },
				React.createElement(
					PopupInputField,
					{ onKeyDown: event => {
							if (event.key === "Enter" && generateAvailable) {
								generateAndReturnLink(finalSubmit);
								return;
							}

							const target = event.target;
							setTimeout(() => {
								const text = target.value;
								if (finalSubmit = validSubmitRange(text, work, book, chapter)) {
									generateAvailable = true;
									submitRefCurr.current = submitElem;
									refreshPageController();
								} else if (generateAvailable) {
									generateAvailable = false;
									submitRefCurr.current = null;
									refreshPageController();
								}
							});
						} },
					range
				)
			));

			pageForward(content);
		}

		function validSubmitRange(text, work, book, chapter) {
			let maxVal;
			if (work === "DC") {
				maxVal = SCRIPTURES.all[work][book];
			} else {
				maxVal = SCRIPTURES.all[work][book][chapter];
			}

			// special case: initializing
			if (text === null) {
				return { work, book, chapter, start: 1, end: maxVal };
			}

			// special case: empty
			else if (text === "") {
					return { work, book, chapter, start: null, end: null };
				}

			const start = parseInt(text);
			// NOTE: Math.abs() gets rid of '-' separated numbers; text adds start so end === start if no end is provided
			const end = Math.abs(parseInt((text + ' ' + start).slice((start + '').length)));
			// basic data validation
			if (!isNaN(start) && !isNaN(end) && start > 0 && start <= end) {
				// checks if within range
				if (end <= maxVal) {
					// checks out!
					return { work, book, chapter, start, end };
				}
			}
			return null;
		}

		function generateAndReturnLink(finalData) {
			const { book, chapter, start, end } = finalData;
			const link = SCRIPTURES.links.makeLink(book, chapter, start, end);
			POPUP.triggerClose(link);
		}

		/* TESTING */
		if (false) {
			const result = await POPUP.promptDeepLink("Generate Link");
			alert(result);

			let doAlert = true;
			window.addEventListener("blur", () => doAlert = false, { once: true });

			const a = document.createElement('a');
			a.href = result;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);

			setTimeout(() => {
				if (doAlert) {
					POPUP.alert("Link did not open...");
				} else {
					POPUP.alert("Link opened!");
				}
			}, 4000);
		}
	}();

	// contains all books and number of verses for each
	const SCRIPTURES = {
		_initScriptures() {
			const rawData = {
				OT: {
					genesis: [31, 25, 24, 26, 32, 22, 24, 22, 29, 32, 32, 20, 18, 24, 21, 16, 27, 33, 38, 18, 34, 24, 20, 67, 34, 35, 46, 22, 35, 43, 55, 32, 20, 31, 29, 43, 36, 30, 23, 23, 57, 38, 34, 34, 28, 34, 31, 22, 33, 26],

					exodus: [22, 25, 22, 31, 23, 30, 25, 32, 35, 29, 10, 51, 22, 31, 27, 36, 16, 27, 25, 26, 36, 31, 33, 18, 40, 37, 21, 43, 46, 38, 18, 35, 23, 35, 35, 38, 29, 31, 43, 38],

					leviticus: [17, 16, 17, 35, 19, 30, 38, 36, 24, 20, 47, 8, 59, 57, 33, 34, 16, 30, 37, 27, 24, 33, 44, 23, 55, 46, 34],

					numbers: [54, 34, 51, 49, 31, 27, 89, 26, 23, 36, 35, 16, 33, 45, 41, 50, 13, 32, 22, 29, 35, 41, 30, 25, 18, 65, 23, 31, 40, 16, 54, 42, 56, 29, 34, 13],

					deuteronomy: [46, 37, 29, 49, 33, 25, 26, 20, 29, 22, 32, 32, 18, 29, 23, 22, 20, 22, 21, 20, 23, 30, 25, 22, 19, 19, 26, 68, 29, 20, 30, 52, 29, 12],

					joshua: [18, 24, 17, 24, 15, 27, 26, 35, 27, 43, 23, 24, 33, 15, 63, 10, 18, 28, 51, 9, 45, 34, 16, 33],

					judges: [36, 23, 31, 24, 31, 40, 25, 35, 57, 18, 40, 15, 25, 20, 20, 31, 13, 31, 30, 48, 25],

					ruth: [22, 23, 18, 22],

					firstSamuel: [28, 36, 21, 22, 12, 21, 17, 22, 27, 27, 15, 25, 23, 52, 35, 23, 58, 30, 24, 42, 15, 23, 29, 22, 44, 25, 12, 25, 11, 31, 13],

					secondSamuel: [27, 32, 39, 12, 25, 23, 29, 18, 13, 19, 27, 31, 39, 33, 37, 23, 29, 33, 43, 26, 22, 51, 39, 25],

					firstKings: [53, 46, 28, 34, 18, 38, 51, 66, 28, 29, 43, 33, 34, 31, 34, 34, 24, 46, 21, 43, 29, 53],

					secondKings: [18, 25, 27, 44, 27, 33, 20, 29, 37, 36, 21, 21, 25, 29, 38, 20, 41, 37, 37, 21, 26, 20, 37, 20, 30],

					firstChronicles: [54, 55, 24, 43, 26, 81, 40, 40, 44, 14, 47, 40, 14, 17, 29, 43, 27, 17, 19, 8, 30, 19, 32, 31, 31, 32, 34, 21, 30],

					secondChronicles: [17, 18, 17, 22, 14, 42, 22, 18, 31, 19, 23, 16, 22, 15, 19, 14, 19, 34, 11, 37, 20, 12, 21, 27, 28, 23, 9, 27, 36, 27, 21, 33, 25, 33, 27, 23],

					ezra: [11, 70, 13, 24, 17, 22, 28, 36, 15, 44],

					nehemiah: [11, 20, 32, 23, 19, 19, 73, 18, 38, 39, 36, 47, 31],

					esther: [22, 23, 15, 17, 14, 14, 10, 17, 32, 3],

					job: [22, 13, 26, 21, 27, 30, 21, 22, 35, 22, 20, 25, 28, 22, 35, 22, 16, 21, 29, 29, 34, 30, 17, 25, 6, 14, 23, 28, 25, 31, 40, 22, 33, 37, 16, 33, 24, 41, 30, 24, 34, 17],

					// dang this is big... look at chapter 119!
					psalms: [6, 12, 8, 8, 12, 10, 17, 9, 20, 18, 7, 8, 6, 7, 5, 11, 15, 50, 14, 9, 13, 31, 6, 10, 22, 12, 14, 9, 11, 12, 24, 11, 22, 22, 28, 12, 40, 22, 13, 17, 13, 11, 5, 26, 17, 11, 9, 14, 20, 23, 19, 9, 6, 7, 23, 13, 11, 11, 17, 12, 8, 12, 11, 10, 13, 20, 7, 35, 36, 5, 24, 20, 28, 23, 10, 12, 20, 72, 13, 19, 16, 8, 18, 12, 13, 17, 7, 18, 52, 17, 16, 15, 5, 23, 11, 13, 12, 9, 9, 5, 8, 28, 22, 35, 45, 48, 43, 13, 31, 7, 10, 10, 9, 8, 18, 19, 2, 29, 176, 7, 8, 9, 4, 8, 5, 6, 5, 6, 8, 8, 3, 18, 3, 3, 21, 26, 9, 8, 24, 13, 10, 7, 12, 15, 21, 10, 20, 14, 9, 6],

					proverbs: [33, 22, 35, 27, 23, 35, 27, 36, 18, 32, 31, 28, 25, 35, 33, 33, 28, 24, 29, 30, 31, 29, 35, 34, 28, 28, 27, 28, 27, 33, 31],

					ecclesiastes: [18, 26, 22, 16, 20, 12, 29, 17, 18, 20, 10, 14],

					songOfSolomon: [17, 17, 11, 16, 16, 13, 13, 14],

					isaiah: [31, 22, 26, 6, 30, 13, 25, 22, 21, 34, 16, 6, 22, 32, 9, 14, 14, 7, 25, 6, 17, 25, 18, 23, 12, 21, 13, 29, 24, 33, 9, 20, 24, 17, 10, 22, 38, 22, 8, 31, 29, 25, 28, 28, 25, 13, 15, 22, 26, 11, 23, 15, 12, 17, 13, 12, 21, 14, 21, 22, 11, 12, 19, 12, 25, 24],

					jerimiah: [19, 37, 25, 31, 31, 30, 34, 22, 26, 25, 23, 17, 27, 22, 21, 21, 27, 23, 15, 18, 14, 30, 40, 10, 38, 24, 22, 17, 32, 24, 40, 44, 26, 22, 19, 32, 21, 28, 18, 16, 18, 22, 13, 30, 5, 28, 7, 47, 39, 46, 64, 34],

					lamentations: [22, 22, 66, 22, 22],

					ezekiel: [28, 10, 27, 17, 17, 14, 27, 18, 11, 22, 25, 28, 23, 23, 8, 63, 24, 32, 14, 49, 32, 31, 49, 27, 17, 21, 36, 26, 21, 26, 18, 32, 33, 31, 15, 38, 28, 23, 29, 49, 26, 20, 27, 31, 25, 24, 23, 35],

					daniel: [21, 49, 30, 37, 31, 28, 28, 27, 27, 21, 45, 13],

					hosea: [11, 23, 5, 19, 15, 11, 16, 14, 17, 15, 12, 14, 16, 9],

					joel: [20, 32, 21],

					amos: [15, 16, 15, 13, 27, 14, 17, 14, 15],

					obadiah: [21],

					jonah: [17, 10, 10, 11],

					micah: [16, 13, 12, 13, 15, 16, 20],

					nahum: [15, 13, 19],

					habakkuk: [17, 20, 19],

					zephaniah: [18, 15, 20],

					haggi: [15, 23],

					zechariah: [21, 13, 10, 14, 11, 15, 14, 23, 17, 12, 17, 14, 9, 21],

					malachi: [14, 17, 18, 6]
				},

				NT: {
					matthew: [25, 23, 17, 25, 48, 34, 29, 34, 38, 42, 30, 50, 58, 36, 39, 28, 27, 35, 30, 34, 46, 46, 39, 51, 46, 75, 66, 20],

					mark: [45, 28, 35, 41, 43, 56, 37, 38, 50, 52, 33, 44, 37, 72, 47, 20],

					luke: [80, 52, 38, 44, 39, 49, 50, 56, 62, 42, 54, 59, 35, 35, 32, 31, 37, 43, 48, 47, 38, 71, 56, 53],

					john: [51, 25, 36, 54, 47, 71, 53, 59, 41, 42, 57, 50, 38, 31, 27, 33, 26, 40, 42, 31, 25],

					acts: [26, 47, 26, 37, 42, 15, 60, 40, 43, 48, 30, 25, 52, 28, 41, 40, 34, 28, 41, 38, 40, 30, 35, 27, 27, 32, 44, 31],

					romans: [32, 29, 31, 25, 21, 23, 25, 39, 33, 21, 36, 21, 14, 23, 33, 27],

					firstCorinthians: [31, 16, 23, 21, 13, 20, 40, 13, 27, 33, 34, 31, 13, 40, 58, 24],

					secondCorinthians: [24, 17, 18, 18, 21, 18, 16, 24, 15, 18, 33, 21, 14],

					galatians: [24, 21, 29, 31, 26, 18],

					ephesians: [23, 22, 21, 32, 33, 24],

					philippians: [30, 30, 21, 23],

					colossians: [29, 23, 25, 18],

					firstThessalonians: [10, 20, 13, 18, 28],

					secondThessalonians: [12, 17, 18],

					firstTimothy: [20, 15, 16, 16, 25, 21],

					secondTimothy: [18, 26, 17, 22],

					titus: [16, 15, 15],

					philemon: [25],

					hebrews: [14, 18, 19, 16, 14, 20, 28, 13, 28, 39, 40, 29, 25],

					james: [27, 26, 18, 17, 20],

					firstPeter: [25, 25, 22, 19, 14],

					secondPeter: [21, 22, 18],

					firstJohn: [10, 29, 24, 21, 21],

					secondJohn: [13],

					thirdJohn: [14],

					jude: [25],

					revelation: [20, 29, 22, 11, 14, 17, 17, 13, 21, 11, 19, 17, 18, 20, 8, 21, 18, 24, 21, 15, 27, 21]
				},

				BOM: {
					firstNephi: [20, 24, 31, 38, 22, 6, 22, 38, 6, 22, 36, 23, 42, 30, 36, 39, 55, 25, 24, 22, 26, 31],

					secondNephi: [32, 30, 25, 35, 34, 18, 11, 25, 54, 25, 8, 22, 26, 6, 30, 13, 25, 22, 21, 34, 16, 6, 22, 32, 30, 33, 35, 32, 14, 18, 21, 9, 15],

					jacob: [19, 35, 14, 18, 77, 13, 27],

					enos: [27],

					jerom: [15],

					omni: [30],

					wordsOfMormon: [18],

					mosiah: [18, 41, 27, 30, 15, 7, 33, 21, 19, 22, 29, 37, 35, 12, 31, 15, 20, 35, 29, 26, 36, 16, 39, 25, 24, 39, 37, 20, 47],

					alma: [33, 38, 27, 20, 62, 8, 27, 32, 34, 32, 46, 37, 31, 29, 19, 21, 39, 43, 36, 30, 23, 35, 18, 30, 17, 37, 30, 14, 17, 60, 38, 43, 23, 41, 16, 30, 47, 15, 19, 26, 15, 31, 54, 24, 24, 41, 36, 25, 30, 40, 37, 40, 23, 24, 35, 57, 36, 41, 13, 36, 21, 52, 17],

					helaman: [34, 14, 37, 26, 52, 41, 29, 28, 41, 19, 38, 26, 39, 31, 17, 25],

					thirdNephi: [30, 19, 26, 33, 26, 30, 26, 25, 22, 19, 41, 48, 34, 27, 24, 20, 25, 39, 36, 46, 29, 17, 14, 18, 6, 21, 33, 40, 9, 2],

					fourthNephi: [49],

					mormon: [19, 29, 22, 23, 24, 22, 10, 41, 37],

					ether: [43, 25, 28, 19, 6, 30, 27, 26, 35, 34, 23, 41, 31, 31, 34],

					moroni: [4, 3, 4, 3, 2, 9, 48, 30, 26, 34]
				},

				DC: [39, 3, 20, 7, 35, 37, 8, 12, 14, 70, 30, 9, 1, 11, 6, 6, 9, 47, 41, 84, 12, 4, 7, 19, 16, 2, 18, 16, 50, 11, 13, 5, 18, 12, 27, 8, 4, 42, 24, 3, 12, 93, 35, 6, 75, 33, 4, 6, 28, 46, 20, 44, 7, 10, 6, 20, 16, 65, 24, 17, 39, 9, 66, 43, 6, 13, 14, 35, 8, 18, 11, 26, 6, 7, 36, 119, 15, 22, 4, 5, 7, 24, 6, 120, 12, 11, 8, 141, 21, 37, 6, 2, 53, 17, 17, 9, 28, 48, 8, 17, 101, 34, 40, 86, 41, 8, 100, 8, 80, 16, 11, 34, 10, 2, 19, 1, 16, 6, 7, 1, 46, 9, 17, 145, 4, 3, 12, 25, 9, 23, 8, 66, 74, 12, 7, 42, 10, 60],

				PGP: {
					moses: [42, 31, 25, 32, 59, 68, 69, 30],

					abraham: [31, 25, 28, 31, 21],

					josephSmithMatthew: [55],

					josephSmithHistory: [75],

					articlesOfFaith: [13]
				}
			};

			this.all = {};
			let allBooks = 0;
			let allChaps = 0;
			let allVerses = 0;
			for (const secName in rawData) {
				const rawSec = rawData[secName];
				let sec = {};
				let secBooks = 0;
				let secChaps = 0;
				let secVerses = 0;

				// special case for doctrine and covenants...
				if (secName === "DC") {
					sec = rawSec;
					secBooks++; // only one "book", right?
					secChaps = rawSec.length;
					secVerses = rawSec.reduce((a, b) => a + b);
				}

				// ...normal branch
				else {
						for (const bookName in rawSec) {
							const book = sec[bookName] = rawSec[bookName];
							secBooks++;

							const bookChaps = book.length;
							const bookVerses = book.reduce((a, b) => a + b);
							Object.defineProperties(book, {
								chaps: { value: bookChaps },
								verses: { value: bookVerses }
							});

							secChaps += bookChaps;
							secVerses += bookVerses;
						}
					}

				// makes them non-enumerable (by default)
				Object.defineProperties(sec, {
					books: { value: secBooks },
					chaps: { value: secChaps },
					verses: { value: secVerses }
				});

				this.all[secName] = sec;
				allBooks += sec.books;
				allChaps += sec.chaps;
				allVerses += sec.verses;
			}

			Object.defineProperties(this.all, {
				books: { value: allBooks },
				chaps: { value: allChaps },
				verses: { value: allVerses }
			});

			this.links = {
				base(source = "scriptures") {
					return \`gospellibrary://content/study/\${source}/\`;
				},
				makeLink(book, chap = '1', versesStart = null, versesEnd = versesStart) {
					let link = SCRIPTURES.links.base() + SCRIPTURES.links.fromBook(book) + (parseInt(chap) + 1);
					if (versesStart !== null) {
						link += \`?id=p\${versesStart}-p\${versesEnd}#p\${versesStart - 1}\`;
					}
					return link;
				},
				fromBook(name) {
					return {
						genesis: "ot/gen/",
						exodus: "ot/ex/",
						leviticus: "ot/lev/",
						numbers: "ot/num/",
						deuteronomy: "ot/deut/",
						joshua: "ot/josh/",
						judges: "ot/judg/",
						ruth: "ot/ruth/",
						firstSamuel: "ot/1-sam/",
						secondSamuel: "ot/2-sam/",
						firstKings: "ot/1-kgs/",
						secondKings: "ot/2-kgs/",
						firstChronicles: "ot/1-chr/",
						secondChronicles: "ot/2-chr/",
						ezra: "ot/ezra/",
						nehemiah: "ot/neh/",
						esther: "ot/esth/",
						job: "ot/job/",
						psalms: "ot/ps/",
						proverbs: "ot/prov/",
						ecclesiastes: "ot/eccl/",
						songOfSolomon: "ot/song/",
						isaiah: "ot/isa/",
						jerimiah: "ot/jer/",
						lamentations: "ot/lam/",
						ezekiel: "ot/ezek/",
						daniel: "ot/dan/",
						hosea: "ot/hosea/",
						joel: "ot/joel/",
						amos: "ot/amos/",
						obadiah: "ot/obad/",
						jonah: "ot/jonah/",
						micah: "ot/micah/",
						nahum: "ot/nahum/",
						habakkuk: "ot/hab/",
						zephaniah: "ot/zeph/",
						haggi: "ot/hag/",
						zechariah: "ot/zech/",
						malachi: "ot/mal/",

						matthew: "nt/matt/",
						mark: "nt/mark/",
						luke: "nt/luke/",
						john: "nt/john/",
						acts: "nt/acts/",
						romans: "nt/rom/",
						firstCorinthians: "nt/1-cor/",
						secondCorinthians: "nt/2-cor/",
						galatians: "nt/gal/",
						ephesians: "nt/eph/",
						philippians: "nt/philip/",
						colossians: "nt/col/",
						firstThessalonians: "nt/1-thes/",
						secondThessalonians: "nt/2-thes/",
						firstTimothy: "nt/1-tim/",
						secondTimothy: "nt/2-tim/",
						titus: "nt/titus/",
						philemon: "nt/philem/",
						hebrews: "nt/heb/",
						james: "nt/james/",
						firstPeter: "nt/1-pet/",
						secondPeter: "nt/2-pet/",
						firstJohn: "nt/1-jn/",
						secondJohn: "nt/2-jn/",
						thirdJohn: "nt/3-jn/",
						jude: "nt/jude/",
						revelation: "nt/rev/",

						firstNephi: "bofm/1-ne/",
						secondNephi: "bofm/2-ne/",
						jacob: "bofm/jacob/",
						enos: "bofm/enos/",
						jerom: "bofm/jarom/",
						omni: "bofm/omni/",
						wordsOfMormon: "bofm/w-of-m/",
						mosiah: "bofm/mosiah/",
						alma: "bofm/alma/",
						helaman: "bofm/hel/",
						thirdNephi: "bofm/3-ne/",
						fourthNephi: "bofm/4-ne/",
						mormon: "bofm/morm/",
						ether: "bofm/ether/",
						moroni: "bofm/moro/",

						DC: "dc-testament/dc/",

						moses: "pgp/moses/",
						abraham: "pgp/abr/",
						josephSmithMatthew: "pgp/js-m/",
						josephSmithHistory: "pgp/js-h/",
						articlesOfFaith: "pgp/a-of-f/"
					}[name];
				}
			};
		},

		prettyName(book, chapter = null) {
			let converted = "";
			if (book === "DC") {
				converted = "D&C";
			} else {
				for (const char of book) {
					if (converted === "") {
						converted += char.toUpperCase();
					}
					// this is also the branch numbers take
					else if (char === char.toLowerCase()) {
							converted += char;
						} else {
							converted += ' ' + char;
						}
				}
			}

			if (chapter !== null) {
				const chapterInt = parseInt(chapter) + 1;
				if (book === "DC") {
					converted += " Section " + chapterInt;
				} else {
					converted += " " + chapterInt;
				}
			}

			return converted.replaceAll("First", "1st").replaceAll("Second", "2nd").replaceAll("Third", "3rd").replaceAll("Fourth", "4th");
		}
	};
	SCRIPTURES._initScriptures();

	class MainApp extends ReactStyles.Component {
		constructor(props) {
			super(props);

			this.state = {
				rootPages: {
					questions: null,
					lessons: null,
					discussions: null
				},
				activePage: null,
				pageLoading: true,
				pageCanLoad: false,

				reorganizeMode: false,

				searchQuery: null, // type: string or null
				searchResults: null,

				alertedThatPagesAreDisabled: false
			};

			this.mainPageRef = React.createRef();

			this.searchIndex = new MainAppSearchIndex();
			this.noteDragHandler = new MainAppNoteDragHandler();
			this.autosaver = new MainAppDataRegistry();

			setTimeout(async () => {
				try {
					for (let i = 0; i < 8; i++) {
						const notebook = await this.addPageElemTo(this.state.rootPages.questions, this.createPageElement("notebook", "notebook " + i));
						for (let i = 0; i < 50; i++) {
							if (i % 20 === 0) {
								await new Promise(res => window.requestAnimationFrame(res));
							}
							this.addPageElemTo(notebook, this.createPageElement("note", "Title " + i, "content " + i));
						}
					}

					await this.addPageElemTo(this.state.rootPages.questions, this.createPageElement("notebook", "last notebook"));
					return;
					for (let i = 0; i < 10; i++) {
						const notebook = await this.addPageElemTo(this.state.rootPages.questions, this.createPageElement("notebook", "notebook " + i));
						this.addPageElemTo(notebook, this.createPageElement("note", "Title " + 0, "content " + 0));
						this.addPageElemTo(notebook, this.createPageElement("note", "Title " + i, "content " + i));
					}
				} catch (error) {
					const cons = console;
					cons.logError("(init test)", error);
				}
			}, 200);
		}

		/* RENDERING FUNCTIONS */
		makeStyle(when) {
			return {
				"=body": {
					backgroundColor: PRESET("deepNavy")
				},

				"=.MainApp-Background": {
					position: "absolute",
					top: "0px",
					left: "0px",

					width: "100vw",
					height: "100vh",
					boxSizing: "border-box",

					paddingRight: "env(safe-area-inset-right)",
					paddingLeft: "env(safe-area-inset-left)",
					paddingTop: () => this.state.fullscreen ? "max(12px, env(safe-area-inset-top))" : "env(safe-area-inset-top)",
					paddingBottom: () => this.state.fullscreen ? "env(safe-area-inset-bottom)" : "max(50px, env(safe-area-inset-bottom))",

					'*': {
						[when(":focus")]: {
							outline: "none"
						},

						[when("::-moz-focus-inner")]: {
							border: "none"
						}
					}
				},

				width: "100%",
				height: "100%",
				display: "flex",
				flexFlow: "column nowrap",
				alignItems: "center",

				MainPageLoadingWrapper: {
					width: "96%",
					height: "100%",

					[when("loading")]: {
						MainPage: {
							opacity: 0, // used instead of manipulating display, which causes textarea bugs
							transform: "scale(0)" // used to disable scrolling during loading
						},

						LoadingContainer: {
							display: "flex"
						}
					},

					PageCenter: {
						width: "100%",
						height: "100%",

						position: "absolute",
						top: "0px",
						left: "0px",

						display: "flex",
						alignItems: "center",
						justifyContent: "center",

						h1: {
							color: PRESET("darkGrey")
						}
					},

					MainPage: {
						margin: "2px 0px",
						position: "relative", // hook for PageCenter

						// flex given to animation group so "alignSelf" works in AddBarButton
						DropdownAnimationGroup: {
							width: "100%",
							height: "100%",

							display: "flex",
							flexFlow: "column nowrap",
							alignItems: "stretch"
						},

						PageContentContainer: {
							width: "100%",
							height: "100%",

							boxSizing: "border-box",
							overflowY: "scroll",
							padding: "3px 0px",

							DropdownBar: {
								margin: "5px 0px"
							}
						}
					},

					LoadingContainer: {
						display: "none"
					}
				},

				AddBarButton: {
					width: "80px",
					height: "40px",
					paddingRight: 0.23 * 40 + "px", // makes the whole thing look centered

					alignSelf: "center",

					display: "flex",
					flexFlow: "row nowrap",
					alignItems: "center",

					[when(":active")]: {
						backgroundColor: PRESET("activeBlue", { alpha: 0.3 })
					},

					'>*': {
						margin: "0px",
						padding: "0px",

						width: "40px",
						height: "40px"
					},

					'svg': {
						stroke: PRESET("activeBlue")
					},

					'>button': {
						flex: "0 0 auto", // maintains manual width

						backgroundColor: PRESET("clear"),
						color: PRESET("activeBlue"),
						border: "none",
						fontSize: "20px"
					}
				},

				AddNoteButtonCenterWrapper: {
					width: "100%",
					display: "flex",
					flexFlow: "row nowrap",
					alignItems: "center",
					justifyContent: "center"
				},
				AddNoteButton: {
					width: "90px",
					height: "30px",
					paddingRight: 0.23 * 30 + "px", // makes the whole thing look centered

					float: "center",

					display: "flex",
					flexFlow: "row nowrap",
					alignItems: "center",

					[when(":active")]: {
						backgroundColor: PRESET("activeBlue", { alpha: 0.3 })
					},

					'>*': {
						margin: "0px",
						padding: "0px"
					},

					'svg': {
						width: "30px",
						height: "30px",
						stroke: PRESET("activeBlue"),
						zIndex: -1 // dont paint over notes during drag
					},

					'>button': {
						width: "60px",
						height: "30px",
						flex: "0 0 auto", // maintains manual width

						backgroundColor: PRESET("clear"),
						color: PRESET("activeBlue"),
						border: "none",
						fontSize: "12px"
					}
				}
			};
		}

		/* RENDERING */
		render() {
			return React.createElement(
				"div",
				{ className: "MainApp-Background" },
				React.createElement(
					"div",
					{ className: "MainApp" },
					React.createElement(MainAppTopBar, {
						selectedIdx: 0,
						onButtonClick: idx => {
							if (idx !== 0 && !this.state.alertedThatPagesAreDisabled) {
								POPUP.alert("'Lesson' and 'Discussion' pages are not yet implemented");
								this.setState({ alertedThatPagesAreDisabled: true });
							}
						},
						onSearchClick: query => this.search(query),
						onSearchInactive: () => this.onSearchBack(),
						menuContentChanged: false,
						menuContent: [React.createElement(
							"button",
							{ onClick: async () => {
									const link = await POPUP.promptDeepLink();
									if (link) {
										ClipboardOperator.copyToClipboard(link);
										POPUP.alert("Link copied to clipboard!");
									}
								} },
							"Generate"
						), React.createElement(
							"button",
							{ onClick: () => {
									try {
										const { rootPages } = this.state;
										this.autosaver.saveNotes([rootPages.questions, rootPages.lessons, rootPages.discussions]);
										this.autosaver.saveSearchIndex(this.searchIndex.getSerializedStr());
										POPUP.alert("Saved notes successfully!");
									} catch (error) {
										POPUP.alert(error + '');
									}
								} },
							"Save Notes"
						), React.createElement(
							"button",
							{ onClick: () => {
									POPUP.alert({ title: \`Gospel Notes v\${VERSION.number}\`, subtitle: "// TODO: make credits look pretty" });
									// POPUP.alert({title: \`Gospel Notes v\${VERSION.number}\`, subtitle: VERSION.credits})
								} },
							"Version"
						), React.createElement(
							"button",
							{ onClick: async () => {
									if (await POPUP.confirm("This will clear saved data and refresh the main page. Continue?")) {
										this.autosaver.hardReset();

										this.searchIndex = new MainAppSearchIndex();

										this.state.rootPages = null;
										this.state.activePage = null;
										this.createRootPageElements();

										this.loadSearchIndex();

										this.setState({
											reorganizeMode: false,
											searchQuery: null,
											searchResults: null
										});
									}
								} },
							"!RESET!"
						)]
					}),
					React.createElement(
						"div",
						{ className: \`MainPageLoadingWrapper \${this.state.pageLoading ? "loading" : ''}\` },
						React.createElement(
							MainPage,
							{ ref: this.mainPageRef, canLoad: this.state.pageCanLoad },
							() => this.renderPage()
						),
						this.renderLoading()
					)
				)
			);
		}

		renderPage() {
			let pageContent;
			if (this.state.searchResults) {
				pageContent = this.renderSearchResults();
			} else {
				pageContent = this.renderPageContent();
			}

			return React.createElement(
				"div",
				{ className: "PageContentContainer" },
				React.createElement(
					DropdownAnimationGroup,
					null,
					pageContent
				)
			);
		}

		renderPageContent() {
			if (!this.state.activePage) {
				return null;
			}

			return this.state.activePage.mapChildren(pageElem => {
				return this.renderPageElem(pageElem);
			}).concat(this.renderAddBarButton(this.state.activePage));
		}

		renderPageElem(pageElem) {
			const { ref, id } = pageElem;

			switch (pageElem.type) {
				case "folder":
					{
						return null;
					}
					break;

				case "notebook":
					{
						// <Reorderable key={id} ordering={this.state.reorganizeMode}>
						return React.createElement(
							MainPageDropdown,
							{
								ref: ref,
								key: id,
								source: pageElem,
								onRename: () => this.promptRenamePageElem(pageElem)
							},
							() => {
								const children = pageElem.mapChildren(child => this.renderPageElem(child));
								return children.concat(this.renderAddNoteButton(pageElem));
							}
						);
					}
					break;

				case "note":
					{
						// handles deleting completely blank notes (in a UI-fluid way)
						if (!pageElem.title && !pageElem.content) {
							setTimeout(() => this.removeElemFromParent(pageElem)); // allows paint first
							return null; // skips rendering to "pre-remove" the note
						}

						const dragRef = React.createRef();
						const onDrop = (oldIdx, newIdx) => {
							if (oldIdx !== newIdx) {
								this.moveNoteInParent(pageElem, newIdx);
							}
						};

						return React.createElement(MainPageNoteBox, {
							ref: ref,
							key: id,
							source: pageElem,

							onTitleChange: newTitle => this.setNoteData(pageElem, { title: newTitle }),
							onContentChange: newContent => this.setNoteData(pageElem, { content: newContent }),

							dragRef: dragRef,
							beforeDrag: (initX, initY) => this.noteDragHandler.beforeDrag(dragRef.current, initX, initY),
							onDrag: (x, y, addOffset) => this.noteDragHandler.onDrag(x, y, addOffset),
							afterDrag: () => this.noteDragHandler.afterDrag(onDrop)
						});
					}
					break;
			}
		}

		renderAddBarButton(parentElem) {
			return React.createElement(
				"div",
				{ className: "AddBarButton", onClick: () => this.promptAddPageElem(parentElem, "notebook") },
				React.createElement(SVGIcon, { type: "plus" }),
				React.createElement(
					"button",
					null,
					"Add"
				)
			);
		}

		renderAddNoteButton(parentElem) {
			return React.createElement(
				"div",
				{ className: "AddNoteButtonCenterWrapper" },
				React.createElement(
					"div",
					{ className: "AddNoteButton", onClick: () => this.addPageElemTo(parentElem, this.createPageElement("note", "Title", "(content)")) },
					React.createElement(SVGIcon, { type: "plus" }),
					React.createElement(
						"button",
						null,
						"Add Note"
					)
				)
			);
		}

		renderLoading() {
			return React.createElement(
				"div",
				{ className: "LoadingContainer" },
				React.createElement(
					"div",
					{ className: "PageCenter" },
					React.createElement(LoadingCircle, null)
				)
			);
		}

		renderSearchResults() {
			const { groupResults, noteResults } = this.state.searchResults;
			if (groupResults.length === 0 && noteResults.length === 0) {
				return React.createElement(
					"div",
					{ className: "PageCenter" },
					React.createElement(
						"h1",
						null,
						"No results"
					)
				);
			}

			const groupElems = groupResults.map(({ pageElem }) => this.renderPageElem(pageElem));
			const noteElems = noteResults.map(({ pageElem }) => this.renderPageElem(pageElem));

			const fullResults = groupElems.concat(noteElems);
			return fullResults;
		}

		/* LIFECYCLE FUNCTIONS */
		async componentDidMount() {
			const valid = this.autosaver.ensureVersion();
			if (!valid) {
				const confirmed = await POPUP.confirm({
					title: "WARNING: Bad autosave!",
					subtitle: \`You are attempting to run a newer	version of
						Gospel Notes. If you choose to proceed, your save file
						will be wiped.
						\\\\n\\\\n
						If you wish to download a backup first, please load an
						older version into this directory and back up
						from there.\`.replaceAll('\\n', '').replaceAll('\\\\n', '\\n')
				});

				if (confirmed) {
					this.autosaver.hardReset();
				} else {
					await POPUP.alert("The app will now crash to prevent corrupting your data");
					ReactDOM.render(null, root);
					throw new Error("CRASH ME PLZ");
				}
			}

			const sleep = new Promise(res => setTimeout(res, 1400));
			this.createRootPageElements();
			this.loadSearchIndex();
			await this.setState({ pageCanLoad: true });
			await sleep;
			this.setState({ pageLoading: false, pageCanLoad: false });
		}

		createRootPageElements() {
			let data = this.autosaver.loadNotes();
			if (!data) {
				data = [new PageFolder("questions"), new PageFolder("lessons"), new PageFolder("discussions")];
			}
			const [questions, lessons, discussions] = data;

			// NOTE: these are needed immediately for later init functions
			this.state.rootPages = { questions, lessons, discussions };
			this.state.activePage = questions;
		}

		loadSearchIndex() {
			const idxData = this.autosaver.loadSearchIndex();
			if (idxData) {
				// saved before
				this.searchIndex.loadFromSerialized(idxData, this.state.rootPages);
			} else {
				// not saved before
				const { questions, lessons, discussions } = this.state.rootPages;
				this.searchIndex.addPageElem(questions);
				this.searchIndex.addPageElem(lessons);
				this.searchIndex.addPageElem(discussions);
			}
		}

		async updateMainPage() {
			await this.mainPageRef.current.forceUpdate();
		}

		async waitForAnimation() {
			return new Promise(res => setTimeout(res));
		}

		/* PAGE ELEMENT MODIFICATION */
		createPageElement(type, ...args) {
			switch (type) {
				case "folder":
					{
						const [name] = args;
						return new PageFolder(name);
					}
					break;

				case "notebook":
					{
						const [name] = args;
						return new PageNotebook(name);
					}
					break;

				case "note":
					{
						const [title, content] = args;
						return new PageNote(title, content);
					}
					break;

				default:
					{
						throw new Error("Cannot add invalid page element type " + type);
					}
					break;
			}
		}

		async promptAddPageElem(parentElem, type, prompt = "Enter name") {
			if (this.state.searchQuery !== null) {
				return;
			}

			const name = await POPUP.prompt(prompt);
			if (name) {
				try {
					const newElem = this.createPageElement(type, name);
					await this.addPageElemTo(parentElem, newElem);
				} catch (error) {
					if ((error + '').includes("already exists")) {
						this.promptAddPageElem(parentElem, type, { title: "Please enter a unique name", subtitle: \`'\${name}' already exists\` });
					}
				}
			}
		}
		async addPageElemTo(parentElem, newElem) {
			if (!PageElementBase.isPageElement(parentElem) || !PageElementBase.isPageElement(newElem)) {
				throw new Error("addPageElemTo only accepts page element arguments");
			}
			parentElem.addChild(newElem);

			if (parentElem === this.state.activePage) {
				await this.updateMainPage();
			} else {
				await parentElem.triggerUpdate();
			}

			this.searchIndex.addPageElem(newElem);

			return newElem;
		}

		async promptRenamePageElem(pageElem) {
			if (this.state.searchQuery !== null) {
				return;
			}

			const newName = await POPUP.prompt({ title: "Enter new name", subtitle: "(Leave blank to delete)" }, pageElem.name);
			if (newName === '') {
				if (await POPUP.confirm("Delete " + pageElem.name + '?')) {
					this.removePageElem(pageElem);
				}
			} else if (newName) {
				this.renamePageElem(pageElem, newName);
			}
		}
		async renamePageElem(pageElem, newName) {
			const oldName = pageElem.name;
			pageElem.name = newName;

			await pageElem.triggerUpdate();

			this.searchIndex.pageElemRenamed(pageElem);
		}

		async removePageElem(pageElem) {
			const parent = pageElem.parent;
			parent.removeChild(pageElem);

			await parent.triggerUpdate();

			this.searchIndex.pageElemUpdated(parent);
		}

		/* NOTE MODIFICATION */
		async setNoteData(pageElem, change) {
			const { title, content } = change;

			if (typeof title === "string") {
				pageElem.title = title;
			}

			if (typeof content === "string") {
				pageElem.content = content;
			}

			await pageElem.triggerUpdate();

			this.searchIndex.pageElemUpdated(pageElem);
		}

		async moveNoteInParent(noteElem, idx) {
			const parent = noteElem.parent;
			parent.moveChild(noteElem, idx);

			await parent.triggerUpdate();
		}

		/* SEARCHING */
		async search(query) {
			await this.setState({ pageLoading: true, searchQuery: query });
			await this.waitForAnimation();
			const sleep = new Promise(res => {
				setTimeout(res, 900);
			});

			// filters so only children of these will show
			const validParents = [this.state.rootPages.questions, this.state.rootPages.lessons, this.state.rootPages.discussions];
			const results = this.searchIndex.search(validParents, query);
			await this.setState({ pageCanLoad: true, searchResults: results });

			// ensure loading takes at least the sleep time
			await sleep;
			await this.setState({ pageLoading: false, pageCanLoad: false });
		}

		async onSearchBack() {
			await this.setState({ pageLoading: true });
			await this.waitForAnimation();
			const sleep = new Promise(res => {
				setTimeout(res, 200);
			});

			await this.setState({ pageCanLoad: true, searchQuery: null, searchResults: null });

			await sleep;
			await this.setState({ pageLoading: false, pageCanLoad: false });
		}
	}

	ReactDOM.render(React.createElement(MainApp, null), root);
};

// run the app
try {
	main();
}

// oh noes!
catch (error) {
	const errorStr = error + '';
	const possibleErrors = ["React is not defined", "ReactDOM is not defined", "lunr is not defined"];

	let missingLib = false;
	for (const error of possibleErrors) {
		if (errorStr.includes(error)) {
			missingLib = true;
			break;
		}
	}

	if (missingLib) {
		const background = document.createElement("div");
		root.appendChild(background);

		const oops = document.createElement("h1");
		oops.innerHTML = "Sorry about that...";
		background.appendChild(oops);

		const message = document.createElement('p');
		message.innerHTML = \`\\
			It seems like you tried to run
			Gospel Notes without some necessary
			files! Try getting this app again,
			and make sure to keep it in the
			'GospelNotes/' folder.\`.replace('\\n', '');
		background.appendChild(message);

		// make the error screen look pretty!
		background.style["background-color"] = "rgb(37, 37, 48)"; // deepNavy

		background.style.width = "100vw";
		background.style.height = "100vh";
		background.style.padding = "5vw";
		background.style["box-sizing"] = "border-box";

		background.style.position = "absolute";
		background.style.top = "0px";
		background.style.left = "0px";

		background.style.display = "flex";
		background.style["flex-flow"] = "column nowrap";
		background.style["justify-content"] = "center";
		background.style["align-items"] = "center";

		oops.style.color = "rgb(200, 200, 200)"; // softWhite
		oops.style["text-align"] = "center";
		oops.style["font-family"] = "sans-serif";
		oops.style["font-size"] = "10vw";

		oops.style["margin-bottom"] = "1vw";

		message.style.color = "rgb(200, 200, 200)"; // softWhite
		message.style["text-align"] = "center";
		message.style["font-family"] = "sans-serif";
		message.style["font-size"] = "5vw";
	} else {
		throw error; // allows the big nasty RENDER ERROR to show up
	}
}`)
						}
						catch (error) {
											root.style['background-color'] = "red"
				root.style.color = "white"
				root.innerHTML = `(Execution failed!) ${error}`
						}
					</script>
					<script>
						// keeps variables from polluting window
						(() => {
							// strips extra html (when main script escapes prematurely)
							const root = document.getElementById("root")
							const elem = root.children[0]
							// extra checks so user will never accidentally activate this code
							if (elem.innerHTML === "(Javascript did not load)" && elem.style["background-color"] === "rgb(254, 1, 2)") {
								const idx = document.body.innerHTML.indexOf("/div>") + "/div>".length
								document.body.innerHTML = document.body.innerHTML.slice(0, idx)
							}
						})()
					</script>
				</body>
			</html>